name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:
  schedule:
    # ------------------------------------------------------------
    # NORMAL CRON (baseline)
    # - Siempre corre cada 3h, pase lo que pase
    # ------------------------------------------------------------
    - cron: "23 */3 * * *"

    # ------------------------------------------------------------
    # OBSERVER (cada 2 minutos)
    # - Observa estado (PLAYING/IDLE)
    # - Rearma latch al quedar IDLE
    # - Anti-stuck cooldown si latch queda false demasiado tiempo
    # - Si detecta CAMBIO de estado => gatilla update del README 1 vez
    # ------------------------------------------------------------
    - cron: "*/2 * * * *"

    # ------------------------------------------------------------
    # FAST TRIGGER (cada 1 minuto)
    # - Dispara UNA vez cuando detecta playback y latch está armado
    # - Luego deja latch desarmado para evitar spam
    # ------------------------------------------------------------
    - cron: "* * * * *"

permissions:
  contents: write

# ------------------------------------------------------------
# IMPORTANTE:
# - No cancelamos runs en progreso.
# - El anti-spam real lo hace el latch (persistente en repo).
# ------------------------------------------------------------
concurrency:
  group: spotify-telemetry
  cancel-in-progress: false

env:
  ENABLE_FAST_POLL: "true"        # true/false
  FAST_POLL_MODE: "PLAYING_ONLY"  # PLAYING_ONLY | ANY_SESSION

  # ------------------------------------------------------------
  # Estado observado (diagnóstico + para detectar cambios)
  # ------------------------------------------------------------
  STATE_FILE: ".github/state/spotify_playback_state.json"

  # ------------------------------------------------------------
  # Latch state (persistente en repo)
  # armed=true  => listo para disparar una vez
  # armed=false => ya disparó (no repite) hasta que se rearme
  # ------------------------------------------------------------
  LATCH_FILE: ".github/state/spotify_fastpoll_latch.json"

  # ------------------------------------------------------------
  # Anti-stuck: si latch queda “false” demasiado tiempo,
  # se rearma automáticamente después de X minutos.
  # ------------------------------------------------------------
  LATCH_COOLDOWN_MINUTES: "20"

  # ------------------------------------------------------------
  # Marker para forzar diff visible en README sin tocar spotify_telemetry.py
  # (se actualiza SOLO cuando observer/fast gatillan)
  # ------------------------------------------------------------
  README_MARKER_BEGIN: "<!-- SPOTIFY_PLAYBACK_STATE:BEGIN -->"
  README_MARKER_END: "<!-- SPOTIFY_PLAYBACK_STATE:END -->"

  # ------------------------------------------------------------
  # Strings exactos para identificar qué schedule se ejecutó
  # ------------------------------------------------------------
  CRON_BASELINE: "23 */3 * * *"
  CRON_OBSERVER: "*/2 * * * *"
  CRON_FAST: "* * * * *"

# =====================================================================
# JOB 1) BASELINE (cada 3h): comportamiento original
# =====================================================================
jobs:
  baseline:
    name: Baseline (3h)
    if: github.event_name == 'workflow_dispatch' || (github.event_name == 'schedule' && github.event.schedule == '23 */3 * * *')
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------
      # Debug: saber qué disparó esto
      # ------------------------------------------------------------
      - name: Debug context (baseline)
        run: |
          set -euo pipefail
          echo "event_name=${{ github.event_name }}"
          echo "schedule=${{ github.event.schedule || '' }}"
          echo "ref=${{ github.ref }}"
          echo "sha=${{ github.sha }}"

      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # Telemetry normal (tu script, sin tocar)
      # ------------------------------------------------------------
      - name: Update Spotify telemetry block (baseline)
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          python3 .github/scripts/spotify_telemetry.py

      - name: Commit & push if changed (baseline)
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Baseline: no changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json || true
          git commit -m "chore: update Spotify telemetry (baseline)"
          git push

# =====================================================================
# JOB 2) OBSERVER (cada 2 min): detecta cambio de estado PLAYING<->IDLE
# =====================================================================
  observer:
    name: Observer (2m)
    if: github.event_name == 'schedule' && github.event.schedule == '*/2 * * * *'
    runs-on: ubuntu-latest
    steps:
      - name: Debug context (observer)
        run: |
          set -euo pipefail
          echo "event_name=${{ github.event_name }}"
          echo "schedule=${{ github.event.schedule || '' }}"
          echo "ENABLE_FAST_POLL=${{ env.ENABLE_FAST_POLL }}"
          echo "FAST_POLL_MODE=${{ env.FAST_POLL_MODE }}"

      # ------------------------------------------------------------
      # Gate maestro: si está en false => no-op total
      # ------------------------------------------------------------
      - name: Gate (ENABLE_FAST_POLL)
        id: gate
        run: |
          set -euo pipefail
          EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"
          if [ "${EN}" = "true" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi
          echo "Observer gate enabled=${EN}"

      - uses: actions/checkout@v4
        if: steps.gate.outputs.enabled == 'true'
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        if: steps.gate.outputs.enabled == 'true'
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # Precheck Spotify => playing + why
      # PLAYING_ONLY: currently-playing es la verdad primaria
      # ANY_SESSION: /me/player con device
      # ------------------------------------------------------------
      - name: Spotify precheck (observer)
        id: sp
        if: steps.gate.outputs.enabled == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
        run: |
          set -euo pipefail
          python3 - <<'PY' > /tmp/spotify_check.txt
import os, base64, json, urllib.parse, urllib.request, urllib.error

cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
mode = (os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()

def refresh_token():
  auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
  data = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
  req = urllib.request.Request(
    "https://accounts.spotify.com/api/token",
    data=data,
    headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"},
    method="POST",
  )
  with urllib.request.urlopen(req, timeout=20) as r:
    payload = json.loads(r.read().decode("utf-8","replace"))
    return payload.get("access_token")

def get_json(url, tok):
  req = urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
  try:
    with urllib.request.urlopen(req, timeout=20) as r:
      raw = r.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else None
      return r.status, data
  except urllib.error.HTTPError as e:
    if e.code == 204:
      return 204, None
    try:
      raw = e.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else raw
    except Exception:
      data = None
    return e.code, data
  except Exception:
    return -1, None

playing = False
why = "unknown"

if cid and csec and rt:
  tok = refresh_token()
  if tok:
    if mode == "PLAYING_ONLY":
      c1, d1 = get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
      if c1 == 200 and isinstance(d1, dict):
        playing = bool(d1.get("is_playing"))
        why = "currently_playing_primary"
      elif c1 == 204:
        playing = False
        why = "currently_playing_204"
      else:
        playing = False
        why = f"currently_playing_http_{c1}"
    else:
      c2, d2 = get_json("https://api.spotify.com/v1/me/player", tok)
      if c2 == 200 and isinstance(d2, dict):
        dev = d2.get("device")
        playing = isinstance(dev, dict) and bool(dev)
        why = "player_any_session"
      elif c2 == 204:
        playing = False
        why = "player_204"
      else:
        playing = False
        why = f"player_http_{c2}"
  else:
    playing = False
    why = "token_refresh_failed"
else:
  playing = False
  why = "missing_secrets"

print(("true" if playing else "false") + " " + why)
PY
          PLAYING="$(awk '{print $1}' /tmp/spotify_check.txt | tail -n1 | tr '[:upper:]' '[:lower:]')"
          WHY="$(awk '{print $2}' /tmp/spotify_check.txt | tail -n1)"
          rm -f /tmp/spotify_check.txt
          echo "playing=${PLAYING}" >> "$GITHUB_OUTPUT"
          echo "why=${WHY}" >> "$GITHUB_OUTPUT"
          echo "Observer Spotify playing=${PLAYING} why=${WHY}"

      # ------------------------------------------------------------
      # Observer state + latch maintenance + state-change detect
      # - Escribe STATE_FILE
      # - Rearma latch si IDLE
      # - Cooldown anti-stuck
      # - Expone state_changed=true/false
      # ------------------------------------------------------------
      - name: Observer (state + latch + state-change)
        id: obs
        if: steps.gate.outputs.enabled == 'true'
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          LATCH_FILE: ${{ env.LATCH_FILE }}
          LATCH_COOLDOWN_MINUTES: ${{ env.LATCH_COOLDOWN_MINUTES }}
          PLAYING: ${{ steps.sp.outputs.playing }}
          WHY: ${{ steps.sp.outputs.why }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${STATE_FILE}")" "$(dirname "${LATCH_FILE}")"

          python3 - <<'PY' > /tmp/obs_out.txt
import json, os
from datetime import datetime, timezone

state_path = os.environ["STATE_FILE"]
latch_path = os.environ["LATCH_FILE"]
cooldown_min = int((os.environ.get("LATCH_COOLDOWN_MINUTES","20") or "20").strip())
playing = (os.environ.get("PLAYING","false").lower() == "true")
why = os.environ.get("WHY","unknown")

now = datetime.now(timezone.utc)
now_s = now.strftime("%Y-%m-%d %H:%M:%SZ")
new_state = "PLAYING" if playing else "IDLE"

prev_state = None
try:
  with open(state_path, "r", encoding="utf-8") as f:
    old = json.load(f)
    if isinstance(old, dict):
      prev_state = old.get("state")
except Exception:
  pass

# Si no hay prev_state (primer run), NO consideramos "cambio"
state_changed = (prev_state is not None and prev_state != new_state)

with open(state_path, "w", encoding="utf-8") as f:
  f.write(json.dumps({"state": new_state, "why": why, "updated_utc": now_s}, ensure_ascii=False, indent=2) + "\n")

latch = {"armed": True, "updated_utc": now_s, "last_trigger_utc": None}
try:
  with open(latch_path, "r", encoding="utf-8") as f:
    cur = json.load(f)
    if isinstance(cur, dict):
      latch.update(cur)
except Exception:
  pass

def parse_ts(s):
  if not s:
    return None
  try:
    return datetime.fromisoformat(s.replace("Z","+00:00"))
  except Exception:
    return None

armed = bool(latch.get("armed", True))
last_trigger = parse_ts(latch.get("last_trigger_utc"))

# Cooldown anti-stuck: si latch está false demasiado tiempo => rearm
if not armed:
  if last_trigger is None:
    latch["armed"] = True
    latch["cooldown_rearm_utc"] = now_s
  else:
    age = (now - last_trigger).total_seconds()
    if age >= cooldown_min * 60:
      latch["armed"] = True
      latch["cooldown_rearm_utc"] = now_s

# Si IDLE => siempre rearm
if not playing:
  latch["armed"] = True
  latch["rearm_utc"] = now_s

latch["updated_utc"] = now_s

with open(latch_path, "w", encoding="utf-8") as f:
  f.write(json.dumps(latch, ensure_ascii=False, indent=2) + "\n")

print("state_changed=" + ("true" if state_changed else "false"))
print("prev=" + str(prev_state) + " new=" + new_state)
print("latch_armed=" + ("true" if latch.get("armed", True) else "false"))
PY

          cat /tmp/obs_out.txt
          CHANGED="$(grep '^state_changed=' /tmp/obs_out.txt | cut -d= -f2 | tail -n1)"
          rm -f /tmp/obs_out.txt
          if [ "${CHANGED}" != "true" ]; then CHANGED="false"; fi
          echo "state_changed=${CHANGED}" >> "$GITHUB_OUTPUT"
          echo "Observer: state_changed=${CHANGED}"

      - name: Commit observer files (state + latch) if changed
        if: steps.gate.outputs.enabled == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Observer: no state/latch changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${STATE_FILE}" "${LATCH_FILE}"
          git commit -m "chore: update spotify observer state"
          git push

      # ------------------------------------------------------------
      # Si cambió el estado (PLAYING<->IDLE) => gatillamos README update
      # - 1) corre telemetry.py (tu script)
      # - 2) fuerza un diff estable con marker HTML en README (estado+utc)
      # ------------------------------------------------------------
      - name: Update telemetry + README marker (on state change)
        if: steps.gate.outputs.enabled == 'true' && steps.obs.outputs.state_changed == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          README_MARKER_BEGIN: ${{ env.README_MARKER_BEGIN }}
          README_MARKER_END: ${{ env.README_MARKER_END }}
          PLAYING: ${{ steps.sp.outputs.playing }}
          WHY: ${{ steps.sp.outputs.why }}
        run: |
          set -euo pipefail

          python3 .github/scripts/spotify_telemetry.py

          STATE="IDLE"
          if [ "${PLAYING}" = "true" ]; then STATE="PLAYING"; fi
          UTC="$(date -u '+%Y-%m-%d %H:%M:%SZ')"

          # Marker block (invisible) pero fuerza diff + deja trazabilidad
          BLOCK="${README_MARKER_BEGIN}\nSpotify Playback State: ${STATE}\nWhy: ${WHY}\nUpdated (UTC): ${UTC}\n${README_MARKER_END}"

          python3 - <<'PY'
import os, re
p = "README.md"
begin = os.environ["README_MARKER_BEGIN"]
end = os.environ["README_MARKER_END"]
block = os.environ["BLOCK"]

try:
  s = open(p, "r", encoding="utf-8").read()
except FileNotFoundError:
  s = ""

pattern = re.compile(re.escape(begin) + r".*?" + re.escape(end), re.S)
if pattern.search(s):
  s2 = pattern.sub(block, s)
else:
  # Si no existe, lo agregamos al final con un salto
  if s and not s.endswith("\n"):
    s += "\n"
  s2 = s + "\n" + block + "\n"

open(p, "w", encoding="utf-8").write(s2)
PY
        env:
          BLOCK: ${{ env.README_MARKER_BEGIN }}

      - name: Commit & push README/telemetry (on state change)
        if: steps.gate.outputs.enabled == 'true' && steps.obs.outputs.state_changed == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Observer: no README/telemetry diff (unexpected)."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json || true
          git commit -m "chore: update Spotify telemetry (state change)"
          git push

# =====================================================================
# JOB 3) FAST (cada 1 min): dispara UNA vez por sesión (latch)
# =====================================================================
  fast:
    name: Fast trigger (1m)
    if: github.event_name == 'schedule' && github.event.schedule == '* * * * *'
    runs-on: ubuntu-latest
    steps:
      - name: Debug context (fast)
        run: |
          set -euo pipefail
          echo "event_name=${{ github.event_name }}"
          echo "schedule=${{ github.event.schedule || '' }}"
          echo "ENABLE_FAST_POLL=${{ env.ENABLE_FAST_POLL }}"
          echo "FAST_POLL_MODE=${{ env.FAST_POLL_MODE }}"

      - name: Gate (ENABLE_FAST_POLL)
        id: gate
        run: |
          set -euo pipefail
          EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"
          if [ "${EN}" = "true" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi
          echo "Fast gate enabled=${EN}"

      - uses: actions/checkout@v4
        if: steps.gate.outputs.enabled == 'true'
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        if: steps.gate.outputs.enabled == 'true'
        with:
          python-version: "3.11"

      - name: Spotify precheck (fast)
        id: sp
        if: steps.gate.outputs.enabled == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
        run: |
          set -euo pipefail
          python3 - <<'PY' > /tmp/spotify_check.txt
import os, base64, json, urllib.parse, urllib.request, urllib.error

cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
mode = (os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()

def refresh_token():
  auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
  data = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
  req = urllib.request.Request(
    "https://accounts.spotify.com/api/token",
    data=data,
    headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"},
    method="POST",
  )
  with urllib.request.urlopen(req, timeout=20) as r:
    payload = json.loads(r.read().decode("utf-8","replace"))
    return payload.get("access_token")

def get_json(url, tok):
  req = urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
  try:
    with urllib.request.urlopen(req, timeout=20) as r:
      raw = r.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else None
      return r.status, data
  except urllib.error.HTTPError as e:
    if e.code == 204:
      return 204, None
    try:
      raw = e.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else raw
    except Exception:
      data = None
    return e.code, data
  except Exception:
    return -1, None

playing = False
why = "unknown"

if cid and csec and rt:
  tok = refresh_token()
  if tok:
    if mode == "PLAYING_ONLY":
      c1, d1 = get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
      if c1 == 200 and isinstance(d1, dict):
        playing = bool(d1.get("is_playing"))
        why = "currently_playing_primary"
      elif c1 == 204:
        playing = False
        why = "currently_playing_204"
      else:
        playing = False
        why = f"currently_playing_http_{c1}"
    else:
      c2, d2 = get_json("https://api.spotify.com/v1/me/player", tok)
      if c2 == 200 and isinstance(d2, dict):
        dev = d2.get("device")
        playing = isinstance(dev, dict) and bool(dev)
        why = "player_any_session"
      elif c2 == 204:
        playing = False
        why = "player_204"
      else:
        playing = False
        why = f"player_http_{c2}"
  else:
    playing = False
    why = "token_refresh_failed"
else:
  playing = False
  why = "missing_secrets"

print(("true" if playing else "false") + " " + why)
PY
          PLAYING="$(awk '{print $1}' /tmp/spotify_check.txt | tail -n1 | tr '[:upper:]' '[:lower:]')"
          WHY="$(awk '{print $2}' /tmp/spotify_check.txt | tail -n1)"
          rm -f /tmp/spotify_check.txt
          echo "playing=${PLAYING}" >> "$GITHUB_OUTPUT"
          echo "why=${WHY}" >> "$GITHUB_OUTPUT"
          echo "Fast Spotify playing=${PLAYING} why=${WHY}"

      # ------------------------------------------------------------
      # Latch: si PLAYING=true y armed=true => dispara y desarma
      # ------------------------------------------------------------
      - name: Fast latch decision
        id: latch
        if: steps.gate.outputs.enabled == 'true'
        env:
          LATCH_FILE: ${{ env.LATCH_FILE }}
          PLAYING: ${{ steps.sp.outputs.playing }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${LATCH_FILE}")"

          python3 - <<'PY' > /tmp/latch.txt
import json, os
from datetime import datetime, timezone

p = os.environ["LATCH_FILE"]
playing = (os.environ.get("PLAYING","false").lower() == "true")
now_s = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

latch = {"armed": True, "updated_utc": now_s, "last_trigger_utc": None}
try:
  with open(p, "r", encoding="utf-8") as f:
    cur = json.load(f)
    if isinstance(cur, dict):
      latch.update(cur)
except Exception:
  pass

armed = bool(latch.get("armed", True))

if playing and armed:
  latch["armed"] = False
  latch["last_trigger_utc"] = now_s
  latch["updated_utc"] = now_s
  with open(p, "w", encoding="utf-8") as f:
    f.write(json.dumps(latch, ensure_ascii=False, indent=2) + "\n")
  print("true triggered")
else:
  if not playing:
    print("false not_playing")
  else:
    print("false already_latched")
PY

          RUN="$(awk '{print $1}' /tmp/latch.txt | tail -n1)"
          WHY="$(awk '{print $2}' /tmp/latch.txt | tail -n1)"
          rm -f /tmp/latch.txt

          echo "run=${RUN}" >> "$GITHUB_OUTPUT"
          echo "reason=${WHY}" >> "$GITHUB_OUTPUT"
          echo "Fast latch: run=${RUN} reason=${WHY}"

      - name: Commit latch update (fast)
        if: steps.gate.outputs.enabled == 'true' && steps.latch.outputs.run == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Fast: latch did not change (unexpected)."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${LATCH_FILE}"
          git commit -m "chore: spotify latch trigger"
          git push

      # ------------------------------------------------------------
      # Si fast disparó => actualiza telemetry + marker README (forza diff)
      # ------------------------------------------------------------
      - name: Update telemetry + README marker (fast trigger)
        if: steps.gate.outputs.enabled == 'true' && steps.latch.outputs.run == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          README_MARKER_BEGIN: ${{ env.README_MARKER_BEGIN }}
          README_MARKER_END: ${{ env.README_MARKER_END }}
          PLAYING: ${{ steps.sp.outputs.playing }}
          WHY: ${{ steps.sp.outputs.why }}
        run: |
          set -euo pipefail

          python3 .github/scripts/spotify_telemetry.py

          STATE="IDLE"
          if [ "${PLAYING}" = "true" ]; then STATE="PLAYING"; fi
          UTC="$(date -u '+%Y-%m-%d %H:%M:%SZ')"

          python3 - <<'PY'
import os, re
p = "README.md"
begin = os.environ["README_MARKER_BEGIN"]
end = os.environ["README_MARKER_END"]
state = "PLAYING" if os.environ.get("PLAYING","false").lower() == "true" else "IDLE"
why = os.environ.get("WHY","unknown")
utc = __import__("datetime").datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")

block = f"{begin}\nSpotify Playback State: {state}\nWhy: {why}\nUpdated (UTC): {utc}\n{end}"

try:
  s = open(p, "r", encoding="utf-8").read()
except FileNotFoundError:
  s = ""

pattern = re.compile(re.escape(begin) + r".*?" + re.escape(end), re.S)
if pattern.search(s):
  s2 = pattern.sub(block, s)
else:
  if s and not s.endswith("\n"):
    s += "\n"
  s2 = s + "\n" + block + "\n"

open(p, "w", encoding="utf-8").write(s2)
PY

      - name: Commit & push telemetry if changed (fast trigger)
        if: steps.gate.outputs.enabled == 'true' && steps.latch.outputs.run == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Fast: no telemetry/README diff (unexpected)."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json || true
          git commit -m "chore: update Spotify telemetry (fast trigger)"
          git push
