name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:
    # ------------------------------------------------------------
    # Manual run: siempre corre (igual que el cron normal).
    # Útil para debug / forzar un update.
    # ------------------------------------------------------------
  schedule:
    # ------------------------------------------------------------
    # NORMAL CRON (baseline, “como antes”)
    # - Siempre corre cada 3h, pase lo que pase
    # - No depende del fast poll ni del latch
    # ------------------------------------------------------------
    - cron: "23 */3 * * *"

    # ------------------------------------------------------------
    # FAST POLL (cada 1 minuto)
    # - Solo sirve para disparar UNA vez cuando detecta playback
    # - Con latch: NO repite mientras siga la “misma sesión”
    # - Si no hay playback => no-op (sale rápido)
    # ------------------------------------------------------------
    - cron: "* * * * *"

permissions:
  contents: write

env:
  # ------------------------------------------------------------
  # Toggle maestro del FAST POLL
  #
  # true  => cron 1 min hace precheck + latch
  # false => cron 1 min se vuelve no-op (pero cron 3h sigue normal)
  # ------------------------------------------------------------
  ENABLE_FAST_POLL: "true"        # true/false

  # ------------------------------------------------------------
  # Modo de decisión del fast poll
  #
  # PLAYING_ONLY => requiere is_playing=true (solo cuando suena música)
  # ANY_SESSION  => basta sesión activa (device existe), aunque esté pausado
  # ------------------------------------------------------------
  FAST_POLL_MODE: "PLAYING_ONLY"  # PLAYING_ONLY | ANY_SESSION

  # ------------------------------------------------------------
  # Archivo latch persistente (vive en el repo)
  # - armed=true  => “listo para disparar” cuando detecte playback
  # - armed=false => “ya disparó”, no repetir hasta que se rearme
  # ------------------------------------------------------------
  LATCH_FILE: ".github/state/spotify_fastpoll_latch.json"

jobs:
  telemetry:
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Python runtime
      # ------------------------------------------------------------
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # GUARD + LATCH
      #
      # Objetivo:
      # - Para cron 3h y workflow_dispatch:
      #     => siempre permitir (comportamiento original)
      #
      # - Para cron 1m:
      #     => si ENABLE_FAST_POLL != true => skip inmediato
      #     => si ENABLE_FAST_POLL == true:
      #          1) consultar Spotify (playback real)
      #          2) aplicar latch:
      #             - si NO playback: rearmar latch (armed=true) y NO correr
      #             - si playback:
      #                 * si armed=true => correr UNA vez + desarmar (armed=false)
      #                 * si armed=false => NO correr (ya disparó)
      #
      # Persistencia:
      # - el latch se guarda en .github/state/spotify_fastpoll_latch.json
      # ------------------------------------------------------------
      - name: Guard (fast poll + latch)
        id: guard
        env:
          ENABLE_FAST_POLL: ${{ env.ENABLE_FAST_POLL }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
          LATCH_FILE: ${{ env.LATCH_FILE }}
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          SCHEDULE="${{ github.event.schedule || '' }}"

          # --------------------------------------------------------
          # Defaults:
          # - Permitimos por defecto para NO romper el cron normal (3h)
          # --------------------------------------------------------
          SHOULD_RUN="true"
          REASON="normal_or_manual"
          CHANGED_LATCH="false"

          FAST_CRON="* * * * *"

          # --------------------------------------------------------
          # Aplicar guard SOLO si:
          # - event = schedule
          # - y el cron específico es el fast poll (1m)
          # --------------------------------------------------------
          if [ "${EVENT}" = "schedule" ] && [ "${SCHEDULE}" = "${FAST_CRON}" ]; then
            EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"

            # Fast poll desactivado => no-op
            if [ "${EN}" != "true" ]; then
              SHOULD_RUN="false"
              REASON="fast_poll_disabled"
            else
              # --------------------------------------------------
              # Asegurar directorio de estado
              # --------------------------------------------------
              mkdir -p "$(dirname "${LATCH_FILE}")"

              # --------------------------------------------------
              # Leer latch (armed=true por defecto)
              # --------------------------------------------------
              ARMED="true"
              if [ -f "${LATCH_FILE}" ]; then
                ARMED="$(python3 - <<'PY' "${LATCH_FILE}"
import json, sys
p = sys.argv[1]
try:
  obj = json.load(open(p,"r",encoding="utf-8"))
  armed = obj.get("armed", True)
  print("true" if armed else "false")
except Exception:
  print("true")
PY
                )"
              fi

              ARMED="$(echo "${ARMED}" | tr '[:upper:]' '[:lower:]')"
              if [ "${ARMED}" != "true" ] && [ "${ARMED}" != "false" ]; then
                ARMED="true"
              fi

              # --------------------------------------------------
              # Spotify precheck:
              # - refresh token
              # - /me/player (primario)
              # - fallback /currently-playing si /me/player = 204
              #
              # Salida: "true reason" o "false reason"
              # --------------------------------------------------
              python3 - <<'PY' > /tmp/spotify_check.txt
import os, base64, json, urllib.parse, urllib.request, urllib.error

cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
mode = (os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()

def refresh_token():
  auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
  data = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
  req = urllib.request.Request(
    "https://accounts.spotify.com/api/token",
    data=data,
    headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"},
    method="POST",
  )
  with urllib.request.urlopen(req, timeout=20) as r:
    payload = json.loads(r.read().decode("utf-8","replace"))
    return payload.get("access_token")

def get_json(url, tok):
  req = urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
  try:
    with urllib.request.urlopen(req, timeout=20) as r:
      raw = r.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else None
      return r.status, data
  except urllib.error.HTTPError as e:
    if e.code == 204:
      return 204, None
    try:
      raw = e.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else raw
    except Exception:
      data = None
    return e.code, data
  except Exception:
    return -1, None

playing = False
reason = "unknown"

if cid and csec and rt:
  tok = refresh_token()
  if tok:
    code, data = get_json("https://api.spotify.com/v1/me/player", tok)

    if code == 200 and isinstance(data, dict):
      if mode == "ANY_SESSION":
        dev = data.get("device")
        playing = isinstance(dev, dict) and bool(dev)
        reason = "player_any_session"
      else:
        playing = bool(data.get("is_playing"))
        reason = "player_is_playing"

    elif code == 204:
      # fallback: currently-playing (a veces sirve cuando player=204)
      c2, d2 = get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
      if c2 == 200 and isinstance(d2, dict):
        playing = bool(d2.get("is_playing"))
        reason = "currently_playing_fallback"
      else:
        playing = False
        reason = "no_active_player"
    else:
      playing = False
      reason = f"player_http_{code}"
else:
  playing = False
  reason = "missing_secrets"

print(("true" if playing else "false") + " " + reason)
PY

              PLAYING="$(awk '{print $1}' /tmp/spotify_check.txt | tail -n1 | tr '[:upper:]' '[:lower:]')"
              WHY="$(awk '{print $2}' /tmp/spotify_check.txt | tail -n1)"
              rm -f /tmp/spotify_check.txt

              # --------------------------------------------------
              # LATCH algorithm (la clave para NO repetir)
              #
              # 1) Si NO hay playback:
              #    - NO correr
              #    - rearma latch (armed=true) para el futuro
              #
              # 2) Si HAY playback:
              #    - si armed=true => correr UNA vez y desarmar (armed=false)
              #    - si armed=false => NO correr (ya disparó)
              # --------------------------------------------------
              if [ "${PLAYING}" != "true" ]; then
                SHOULD_RUN="false"
                REASON="not_playing_${WHY}"

                # rearma solo si estaba desarmado
                if [ "${ARMED}" != "true" ]; then
                  python3 - <<'PY' "${LATCH_FILE}"
import json, sys
from datetime import datetime, timezone
p = sys.argv[1]
obj = {"armed": True, "updated_utc": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")}
open(p,"w",encoding="utf-8").write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")
PY
                  CHANGED_LATCH="true"
                fi

              else
                # Playback activo
                if [ "${ARMED}" = "true" ]; then
                  SHOULD_RUN="true"
                  REASON="triggered_${WHY}"

                  # desarma latch para no repetir mientras siga playback
                  python3 - <<'PY' "${LATCH_FILE}"
import json, sys
from datetime import datetime, timezone
p = sys.argv[1]
obj = {"armed": False, "updated_utc": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")}
open(p,"w",encoding="utf-8").write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")
PY
                  CHANGED_LATCH="true"
                else
                  SHOULD_RUN="false"
                  REASON="already_triggered_${WHY}"
                fi
              fi
            fi
          fi

          # --------------------------------------------------------
          # Export decision para pasos siguientes
          # --------------------------------------------------------
          echo "should_run=${SHOULD_RUN}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
          echo "changed_latch=${CHANGED_LATCH}" >> "$GITHUB_OUTPUT"
          echo "event=${EVENT}" >> "$GITHUB_OUTPUT"
          echo "schedule=${SCHEDULE}" >> "$GITHUB_OUTPUT"
          echo "Decision: should_run=${SHOULD_RUN} reason=${REASON} changed_latch=${CHANGED_LATCH} (event=${EVENT}, schedule=${SCHEDULE})"

      # ------------------------------------------------------------
      # Commit latch state (si cambió)
      #
      # Esto hace durable el “solo una vez por sesión”
      # - Si se disparó: armed true -> false
      # - Si se rearma al parar música: false -> true
      #
      # Nota operativa:
      # - Configuramos git user (si no, commit falla)
      # - Pull --rebase para evitar conflictos cuando cron=1m
      # ------------------------------------------------------------
      - name: Commit latch state (if changed)
        if: steps.guard.outputs.changed_latch == 'true'
        run: |
          set -euo pipefail

          if git diff --quiet; then
            echo "No latch changes."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git pull --rebase

          git add .github/state/spotify_fastpoll_latch.json
          git commit -m "chore: fast-poll latch update"
          git push

      # ------------------------------------------------------------
      # Update telemetry (solo si guard dijo "true")
      # ------------------------------------------------------------
      - name: Update Spotify telemetry block (fail-safe)
        if: steps.guard.outputs.should_run == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          python3 .github/scripts/spotify_telemetry.py

      # ------------------------------------------------------------
      # Commit & push README + state (solo si guard dijo "true")
      # - No commitea si no hay cambios
      # - Pull --rebase para evitar fallos por carrera con fast poll
      # ------------------------------------------------------------
      - name: Commit & push if changed
        if: steps.guard.outputs.should_run == 'true'
        run: |
          set -euo pipefail

          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git pull --rebase

          git add README.md .github/state/spotify_last_report.json
          git commit -m "chore: update Spotify telemetry (CLI feed)"
          git push
