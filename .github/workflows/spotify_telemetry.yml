name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:
  schedule:
    # baseline
    - cron: "23 */3 * * *"
    # observer
    - cron: "*/2 * * * *"
    # fast
    - cron: "* * * * *"

permissions:
  contents: write

concurrency:
  group: spotify-telemetry
  cancel-in-progress: false

env:
  ENABLE_FAST_POLL: "true"        # true/false

  # Detect: consider "online" if recently-played moved in last N seconds
  RECENT_ONLINE_SECONDS: "120"

  # State files persisted in repo
  STATE_FILE: ".github/state/spotify_playback_state.json"
  LATCH_FILE: ".github/state/spotify_fastpoll_latch.json"
  FORCE_STAMP_FILE: ".github/state/spotify_force_stamp.txt"

jobs:
  telemetry:
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Python runtime
      # ------------------------------------------------------------
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # Debug context
      # ------------------------------------------------------------
      - name: Debug context
        run: |
          set -euo pipefail
          echo "event_name=${{ github.event_name }}"
          echo "schedule=${{ github.event.schedule || '' }}"
          echo "ref=${{ github.ref }}"
          echo "sha=${{ github.sha }}"

      # ------------------------------------------------------------
      # Master gate for cron-based logic (manual always allowed)
      # ------------------------------------------------------------
      - name: Gate (ENABLE_FAST_POLL)
        id: gate
        run: |
          set -euo pipefail
          EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # manual always runs
            echo "enabled=true" >> "$GITHUB_OUTPUT"
            echo "manual=true"  >> "$GITHUB_OUTPUT"
            exit 0
          fi
          if [ "${EN}" = "true" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi
          echo "manual=false" >> "$GITHUB_OUTPUT"

      # ------------------------------------------------------------
      # Determine "kind" best-effort:
      # baseline if schedule == "23 */3 * * *"
      # observer if schedule == "*/2 * * * *"
      # fast     if schedule == "* * * * *"
      # If GitHub doesn't provide schedule string, fall back to "observer"
      # ------------------------------------------------------------
      - name: Resolve kind
        id: kind
        run: |
          set -euo pipefail
          S="${{ github.event.schedule || '' }}"
          K="observer"
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            K="manual"
          elif [ "${S}" = "23 */3 * * *" ]; then
            K="baseline"
          elif [ "${S}" = "*/2 * * * *" ]; then
            K="observer"
          elif [ "${S}" = "* * * * *" ]; then
            K="fast"
          else
            # if schedule string isn't present, treat as observer (safe)
            K="observer"
          fi
          echo "kind=${K}" >> "$GITHUB_OUTPUT"
          echo "Resolved kind=${K} (schedule='${S}')"

      # ------------------------------------------------------------
      # Spotify effective-state (robust):
      # 1) currently-playing is_playing true => PLAYING
      # 2) else recently-played last played <= RECENT_ONLINE_SECONDS => PLAYING
      # 3) else IDLE
      # ------------------------------------------------------------
      - name: Compute effective playback state (PLAYING/IDLE)
        id: eff
        if: steps.kind.outputs.kind != 'baseline' && steps.kind.outputs.kind != 'manual' && steps.gate.outputs.enabled == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          RECENT_ONLINE_SECONDS: ${{ env.RECENT_ONLINE_SECONDS }}
        run: |
          set -euo pipefail
          python3 - <<'PY' > /tmp/eff.txt
import os, base64, json, urllib.parse, urllib.request, urllib.error
from datetime import datetime, timezone

cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
recent_s = int((os.environ.get("RECENT_ONLINE_SECONDS","120") or "120").strip())

def http_json(url, headers=None, data=None, timeout=20):
  headers = headers or {}
  req = urllib.request.Request(url, headers=headers, data=data)
  try:
    with urllib.request.urlopen(req, timeout=timeout) as r:
      raw = r.read().decode("utf-8","replace").strip()
      if r.status == 204:
        return 204, None
      return r.status, json.loads(raw) if raw else None
  except urllib.error.HTTPError as e:
    if e.code == 204:
      return 204, None
    try:
      raw = e.read().decode("utf-8","replace").strip()
      data = json.loads(raw) if raw else None
    except Exception:
      data = None
    return e.code, data
  except Exception:
    return -1, None

def refresh_token():
  auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
  body = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
  code, payload = http_json("https://accounts.spotify.com/api/token",
                            headers={"Authorization": f"Basic {auth}",
                                     "Content-Type":"application/x-www-form-urlencoded"},
                            data=body, timeout=20)
  if code != 200 or not isinstance(payload, dict):
    return None
  return payload.get("access_token")

def parse_iso_z(s):
  if not s:
    return None
  try:
    return datetime.fromisoformat(s.replace("Z","+00:00"))
  except Exception:
    return None

if not (cid and csec and rt):
  print("IDLE missing_secrets")
  raise SystemExit(0)

tok = refresh_token()
if not tok:
  print("IDLE token_refresh_failed")
  raise SystemExit(0)

# Signal 1: currently-playing
c1, d1 = http_json("https://api.spotify.com/v1/me/player/currently-playing",
                   headers={"Authorization": f"Bearer {tok}"}, timeout=20)
if c1 == 200 and isinstance(d1, dict) and bool(d1.get("is_playing")):
  print("PLAYING currently_playing_is_playing")
  raise SystemExit(0)

# Signal 2: recently-played fresh
c2, d2 = http_json("https://api.spotify.com/v1/me/player/recently-played?limit=1",
                   headers={"Authorization": f"Bearer {tok}"}, timeout=20)
if c2 == 200 and isinstance(d2, dict):
  items = d2.get("items") or []
  if items:
    played_at = (items[0].get("played_at") or "").replace(".000Z","Z")
    dtp = parse_iso_z(played_at)
    if dtp:
      age = (datetime.now(timezone.utc) - dtp).total_seconds()
      if age <= recent_s:
        print("PLAYING recently_played_fresh")
        raise SystemExit(0)

print(f"IDLE no_signal_c1_{c1}_c2_{c2}")
PY
          STATE="$(awk '{print $1}' /tmp/eff.txt | tail -n1)"
          WHY="$(awk '{print $2}' /tmp/eff.txt | tail -n1)"
          rm -f /tmp/eff.txt
          if [ "${STATE}" != "PLAYING" ]; then STATE="IDLE"; fi
          echo "state=${STATE}" >> "$GITHUB_OUTPUT"
          echo "why=${WHY}" >> "$GITHUB_OUTPUT"
          echo "effective_state=${STATE} why=${WHY}"

      # ------------------------------------------------------------
      # Observer: detect state change (PLAYING <-> IDLE)
      # Persist STATE_FILE so we can compare next run.
      # ------------------------------------------------------------
      - name: Observer state (detect change)
        id: obs
        if: steps.kind.outputs.kind == 'observer' && steps.gate.outputs.enabled == 'true'
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          NEW_STATE: ${{ steps.eff.outputs.state }}
          WHY: ${{ steps.eff.outputs.why }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${STATE_FILE}")"

          python3 - <<'PY' > /tmp/obs.txt
import json, os
from datetime import datetime, timezone

p = os.environ["STATE_FILE"]
new_state = (os.environ.get("NEW_STATE") or "IDLE").strip()
why = os.environ.get("WHY") or "unknown"
now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

prev_state = None
try:
  with open(p, "r", encoding="utf-8") as f:
    obj = json.load(f)
    if isinstance(obj, dict):
      prev_state = obj.get("state")
except Exception:
  prev_state = None

changed = (prev_state is not None and prev_state != new_state)

obj = {"state": new_state, "why": why, "updated_utc": now}
with open(p, "w", encoding="utf-8") as f:
  f.write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")

print("changed=" + ("true" if changed else "false"))
print("prev=" + str(prev_state))
print("new=" + str(new_state))
PY

          CHANGED="$(grep -E '^changed=' /tmp/obs.txt | sed 's/changed=//')"
          rm -f /tmp/obs.txt
          if [ "${CHANGED}" != "true" ]; then CHANGED="false"; fi
          echo "changed=${CHANGED}" >> "$GITHUB_OUTPUT"
          echo "observer_changed=${CHANGED}"

      - name: Commit observer state file (if changed)
        if: steps.kind.outputs.kind == 'observer' && steps.gate.outputs.enabled == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Observer: no repo changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${STATE_FILE}"
          git commit -m "chore: spotify observer state"
          git push

      # ------------------------------------------------------------
      # Latch (fast): fire once when PLAYING, then disarm.
      # Re-arm happens via observer when it becomes IDLE (state change).
      # ------------------------------------------------------------
      - name: Fast latch decision
        id: latch
        if: steps.kind.outputs.kind == 'fast' && steps.gate.outputs.enabled == 'true'
        env:
          LATCH_FILE: ${{ env.LATCH_FILE }}
          EFFECTIVE_STATE: ${{ steps.eff.outputs.state }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${LATCH_FILE}")"

          python3 - <<'PY' > /tmp/latch.txt
import json, os
from datetime import datetime, timezone

p = os.environ["LATCH_FILE"]
state = (os.environ.get("EFFECTIVE_STATE") or "IDLE").strip()
now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

latch = {"armed": True, "updated_utc": now, "last_trigger_utc": None}
try:
  with open(p, "r", encoding="utf-8") as f:
    cur = json.load(f)
    if isinstance(cur, dict):
      latch.update(cur)
except Exception:
  pass

armed = bool(latch.get("armed", True))

run = False
reason = "idle"
if state == "PLAYING" and armed:
  run = True
  latch["armed"] = False
  latch["last_trigger_utc"] = now
  reason = "triggered"
elif state == "PLAYING" and not armed:
  run = False
  reason = "already_latched"
else:
  # IDLE: do nothing here; observer handles re-arm on state change
  run = False
  reason = "idle"

latch["updated_utc"] = now
with open(p, "w", encoding="utf-8") as f:
  f.write(json.dumps(latch, ensure_ascii=False, indent=2) + "\n")

print(("true" if run else "false") + " " + reason)
PY

          RUN="$(awk '{print $1}' /tmp/latch.txt | tail -n1)"
          WHY="$(awk '{print $2}' /tmp/latch.txt | tail -n1)"
          rm -f /tmp/latch.txt
          echo "run=${RUN}" >> "$GITHUB_OUTPUT"
          echo "reason=${WHY}" >> "$GITHUB_OUTPUT"
          echo "fast_run=${RUN} reason=${WHY}"

      - name: Commit latch file (fast)
        if: steps.kind.outputs.kind == 'fast' && steps.gate.outputs.enabled == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Fast: no latch changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${LATCH_FILE}"
          git commit -m "chore: spotify fast latch"
          git push

      # ------------------------------------------------------------
      # Decide whether to run telemetry.py
      # baseline/manual: always
      # fast: only if latch run==true
      # observer: only if state changed
      # ------------------------------------------------------------
      - name: Decide telemetry run
        id: run
        run: |
          set -euo pipefail
          K="${{ steps.kind.outputs.kind }}"
          DO="false"

          if [ "${K}" = "baseline" ] || [ "${K}" = "manual" ]; then
            DO="true"
          elif [ "${K}" = "fast" ] && [ "${{ steps.latch.outputs.run || 'false' }}" = "true" ]; then
            DO="true"
          elif [ "${K}" = "observer" ] && [ "${{ steps.obs.outputs.changed || 'false' }}" = "true" ]; then
            DO="true"
          fi

          echo "do=${DO}" >> "$GITHUB_OUTPUT"
          echo "telemetry_do=${DO} (kind=${K})"

      # ------------------------------------------------------------
      # Run your existing telemetry script (UNTOUCHED)
      # ------------------------------------------------------------
      - name: Update Spotify telemetry block (existing script)
        if: steps.run.outputs.do == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          python3 .github/scripts/spotify_telemetry.py

      # ------------------------------------------------------------
      # Force a visible commit when we *expect* a state change,
      # even if README happens to be identical (Spotify 204 / same text).
      # We do this by stamping a repo file.
      # ------------------------------------------------------------
      - name: Force stamp (only when telemetry ran)
        if: steps.run.outputs.do == 'true'
        env:
          FORCE_STAMP_FILE: ${{ env.FORCE_STAMP_FILE }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${FORCE_STAMP_FILE}")"
          date -u +"%Y-%m-%d %H:%M:%SZ" > "${FORCE_STAMP_FILE}"

      # ------------------------------------------------------------
      # Commit & push (README + state + stamp)
      # ------------------------------------------------------------
      - name: Commit & push if changed (or stamp changed)
        if: steps.run.outputs.do == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No changes at all (unexpected because stamp should change)."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json "${FORCE_STAMP_FILE}"
          git commit -m "chore: update Spotify telemetry (CLI feed)"
          git push
