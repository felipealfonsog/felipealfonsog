name: Waka Stats (CLI style)

on:
  workflow_dispatch:
  schedule:
    - cron: '7 0-4,10-15,17-22 * * *'

permissions:
  contents: write

jobs:
  wakastats:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Update wakastats from WakaTime
        env:
          WAKATIME_API_KEY: ${{ secrets.WAKATIME_API_KEY }}
        run: |
          python3 << 'EOF'
          import base64, json, re, urllib.request, os, datetime
          from urllib.parse import urlencode

          API_KEY = os.environ["WAKATIME_API_KEY"]
          auth = base64.b64encode(f"{API_KEY}:".encode()).decode()

          # ===== LOOK & FEEL =====
          EMPTY = "○"
          FULL  = "●"
          HALF  = "◔"
          BAR_LEN = 26

          # ===== SECTION TOGGLES =====
          SHOW_HEADER_INFO       = True
          SHOW_LANGUAGES         = True
          SHOW_OPERATING_SYSTEMS = True
          SHOW_EDITORS           = True
          SHOW_PROJECTS          = True
          SHOW_CATEGORIES        = True
          SHOW_MACHINES          = True
          SHOW_TIME_OF_DAY       = True   # <— now works via summaries endpoint

          # How many days back for "time of day" pattern
          TIME_OF_DAY_DAYS = 30

          # ===== LIMITS =====
          MAX_LANGUAGES  = 10
          MAX_OS         = 6
          MAX_EDITORS    = 8
          MAX_PROJECTS   = 8
          MAX_CATEGORIES = 8
          MAX_MACHINES   = 12

          # ===== CLEANUP =====
          HIDE_UNKNOWN = True
          UNKNOWN_NAMES = {"Unknown Project", "Unknown Editor", "Unknown"}

          def get(url):
              req = urllib.request.Request(
                  url,
                  headers={"Authorization": f"Basic {auth}"}
              )
              with urllib.request.urlopen(req) as r:
                  return json.load(r)

          def clamp(x, lo=0.0, hi=100.0):
              return max(lo, min(hi, x))

          def bar(pct):
              pct = clamp(pct, 0.0, 100.0)
              units = (pct / 100.0) * BAR_LEN
              full = int(units)
              half = 1 if (units - full) >= 0.5 and full < BAR_LEN else 0
              empty = BAR_LEN - full - half
              return (FULL * full) + (HALF * half) + (EMPTY * empty)

          def fmt_hhmm(seconds):
              seconds = int(seconds)
              h = seconds // 3600
              m = (seconds % 3600) // 60
              if h <= 0 and m <= 0:
                  return "0 mins"
              if h <= 0:
                  return f"{m} mins"
              return f"{h} hrs {m} mins"

          def cleaned(items):
              if not items:
                  return []
              out = []
              for i in items:
                  name = (i.get("name") or "").strip()
                  if HIDE_UNKNOWN and (name in UNKNOWN_NAMES or name.startswith("Unknown ")):
                      continue
                  out.append(i)
              return out

          def section(title, items, limit=8, denom=None):
              items = cleaned(items)
              if not items:
                  return ""
              base = int(denom if denom is not None else total) or 1
              out = f"\n{title}\n" + "-" * len(title) + "\n"
              for i in items[:limit]:
                  pct = (i["total_seconds"] / base) * 100.0
                  pct_show = clamp(pct)
                  out += (
                      f"{i['name']:<14} "
                      f"{i['text']:<14} "
                      f"{bar(pct_show)} "
                      f"{pct_show:6.2f} %\n"
                  )
              return out

          def activity_by_time_of_day(days_back: int):
              # Uses summaries endpoint to derive hour-of-day distribution.
              end = datetime.date.today()
              start = end - datetime.timedelta(days=days_back)

              qs = urlencode({
                  "start": start.isoformat(),
                  "end": end.isoformat(),
              })
              data = get(f"https://wakatime.com/api/v1/users/current/summaries?{qs}").get("data", [])

              # Buckets: Morning 05-11, Daytime 12-17, Evening 18-22, Night 23-04
              buckets = {
                  "Morning": 0,
                  "Daytime": 0,
                  "Evening": 0,
                  "Night": 0,
              }

              # WakaTime summaries: each day has "grand_total" and "categories/projects/languages/editors/operating_systems/..."
              # For hour distribution, WakaTime provides "range" blocks in some responses; if not present,
              # we fall back to "projects" etc. Without hour info, we can't compute.
              #
              # The reliable way is to use "summaries" + "range" is not guaranteed for all accounts.
              # However, many accounts expose per-day "range" segments including start/end timestamps.
              #
              # We'll compute from any available "range" start/end per day item.

              found_ranges = False
              for day in data:
                  # Some responses include "range" list with start/end; if present, use it.
                  ranges = day.get("range") or day.get("ranges") or None
                  if not ranges:
                      continue
                  found_ranges = True
                  for r in ranges:
                      # Expected: r["start"], r["end"] ISO timestamps
                      s = r.get("start")
                      e = r.get("end")
                      if not s or not e:
                          continue
                      try:
                          sdt = datetime.datetime.fromisoformat(str(s).replace("Z", "+00:00"))
                          edt = datetime.datetime.fromisoformat(str(e).replace("Z", "+00:00"))
                      except Exception:
                          continue
                      sec = max(0, int((edt - sdt).total_seconds()))
                      hour = sdt.hour
                      if 5 <= hour <= 11:
                          buckets["Morning"] += sec
                      elif 12 <= hour <= 17:
                          buckets["Daytime"] += sec
                      elif 18 <= hour <= 22:
                          buckets["Evening"] += sec
                      else:
                          buckets["Night"] += sec

              if not found_ranges:
                  # If your WakaTime account doesn't expose ranges, we can't compute time-of-day accurately.
                  return "\nACTIVITY BY TIME OF DAY\n----------------------\nN/A (WakaTime summaries did not include time ranges)\n"

              tot = sum(buckets.values()) or 1
              out = "\nACTIVITY BY TIME OF DAY\n----------------------\n"
              for name in ["Morning", "Daytime", "Evening", "Night"]:
                  sec = buckets[name]
                  pct = (sec / tot) * 100.0
                  out += (
                      f"{name:<14} "
                      f"{fmt_hhmm(sec):<14} "
                      f"{bar(pct)} "
                      f"{pct:6.2f} %\n"
                  )
              out += f"\n(Computed from last {days_back} days)\n"
              return out

          # Primary stats (all-time)
          stats = get("https://wakatime.com/api/v1/users/current/stats/all_time")["data"]
          total = int(stats.get("total_seconds", 0)) or 1

          languages = cleaned(stats.get("languages", []))
          mostly = languages[0]["name"] if languages else "N/A"

          days = int(stats.get("days", 1)) or 1
          daily_avg = fmt_hhmm(total / days)

          best = stats.get("best_day")
          best_str = f"{best['date']} — {best['text']}" if best else "N/A"

          content = (
              "WAKATIME EXTENDED STATS\n"
              "======================\n\n"
          )

          if SHOW_HEADER_INFO:
              content += (
                  f"Total Time       : {stats.get('human_readable_total','N/A')}\n"
                  f"Mostly coding in : {mostly}\n"
                  f"Daily average    : {daily_avg}\n"
                  f"Best day         : {best_str}\n"
                  f"Time zone        : {stats.get('timezone','N/A')}\n"
              )

          if SHOW_LANGUAGES:
              content += section("LANGUAGES", stats.get("languages", []), MAX_LANGUAGES)

          if SHOW_TIME_OF_DAY:
              content += activity_by_time_of_day(TIME_OF_DAY_DAYS)

          if SHOW_OPERATING_SYSTEMS:
              content += section("OPERATING SYSTEMS", stats.get("operating_systems", []), MAX_OS)

          if SHOW_EDITORS:
              content += section("EDITORS", stats.get("editors", []), MAX_EDITORS)

          if SHOW_PROJECTS:
              content += section("PROJECTS", stats.get("projects", []), MAX_PROJECTS)

          if SHOW_CATEGORIES:
              content += section("CATEGORIES", stats.get("categories", []), MAX_CATEGORIES)

          machines = cleaned(stats.get("machines", []))
          if SHOW_MACHINES and machines:
              content += "\nMACHINES\n--------\n"
              for m in machines[:MAX_MACHINES]:
                  content += f"{m['name']:<30} {m['text']}\n"

          content = f"```\n{content}\n```"

          with open("README.md", "r", encoding="utf-8") as f:
              readme = f.read()

          new = re.sub(
              r"<!--START_SECTION:wakastats-->.*?<!--END_SECTION:wakastats-->",
              f"<!--START_SECTION:wakastats-->\n{content}\n<!--END_SECTION:wakastats-->",
              readme,
              flags=re.S
          )

          with open("README.md", "w", encoding="utf-8") as f:
              f.write(new)
          EOF

      - name: Commit changes
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add README.md
          git commit -m "Update WakaTime CLI stats" || exit 0
          git push
