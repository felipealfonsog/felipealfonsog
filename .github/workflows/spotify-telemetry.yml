name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:
  schedule:
    # ------------------------------------------------------------
    # NORMAL CRON (baseline, “como antes”)
    # - Siempre corre cada 3h, pase lo que pase
    # ------------------------------------------------------------
    - cron: "23 */3 * * *"

    # ------------------------------------------------------------
    # FAST POLL (cada 1 minuto)
    # - NO spamea commits
    # - Solo ejecuta update cuando detecta CAMBIO de estado
    #   (start/stop playback)
    # ------------------------------------------------------------
    - cron: "* * * * *"

permissions:
  contents: write

env:
  # ------------------------------------------------------------
  # Toggle maestro del fast poll
  # true  => habilita detección rápida (1 min)
  # false => el cron 1 min se vuelve no-op, pero el cron 3h sigue normal
  # ------------------------------------------------------------
  ENABLE_FAST_POLL: "true"        # true/false

  # ------------------------------------------------------------
  # Modo de decisión (qué significa “hay actividad”)
  # PLAYING_ONLY => requiere is_playing=true
  # ANY_SESSION  => basta con que exista device/session
  # ------------------------------------------------------------
  FAST_POLL_MODE: "PLAYING_ONLY"  # PLAYING_ONLY | ANY_SESSION

  # ------------------------------------------------------------
  # Archivo de estado persistente del fast poll (en el repo)
  # Guardamos el último estado observado para detectar transiciones
  # ------------------------------------------------------------
  FASTPOLL_STATE_FILE: ".github/state/spotify_fastpoll_state.json"

  # ------------------------------------------------------------
  # Anti-stuck: si el estado queda pegado, permitimos un refresh
  # ejecutable cada X minutos (solo para el cron 1m)
  # ------------------------------------------------------------
  FASTPOLL_COOLDOWN_MINUTES: "20"

jobs:
  telemetry:
    runs-on: ubuntu-latest
    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Python runtime
      # ------------------------------------------------------------
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # GUARD: decide si este run debe ejecutar el update o no.
      #
      # - Cron 3h: SIEMPRE ejecuta (comportamiento original).
      # - Manual: SIEMPRE ejecuta (workflow_dispatch).
      # - Cron 1m:
      #     - Si ENABLE_FAST_POLL=false => skip
      #     - Si true => consulta Spotify y decide:
      #         Ejecuta SOLO si detecta cambio de estado (start/stop)
      #         o si se cumple el cooldown anti-stuck.
      # ------------------------------------------------------------
      - name: Guard (fast poll: trigger only on state change)
        id: guard
        env:
          ENABLE_FAST_POLL: ${{ env.ENABLE_FAST_POLL }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
          STATE_FILE: ${{ env.FASTPOLL_STATE_FILE }}
          COOLDOWN_MIN: ${{ env.FASTPOLL_COOLDOWN_MINUTES }}
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          SCHEDULE="${{ github.event.schedule || '' }}"
          FAST_CRON="* * * * *"

          SHOULD_RUN="true"
          REASON="normal_or_manual"
          WROTE_STATE="false"

          # --------------------------------------------------------
          # Cron 1m: aplica lógica fast-poll
          # --------------------------------------------------------
          if [ "${EVENT}" = "schedule" ] && [ "${SCHEDULE}" = "${FAST_CRON}" ]; then
            EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"
            if [ "${EN}" != "true" ]; then
              SHOULD_RUN="false"
              REASON="fast_poll_disabled"
            else
              mkdir -p "$(dirname "${STATE_FILE}")"

              # Estado previo (default: false)
              LAST_PLAYING="false"
              LAST_TS=""

              if [ -f "${STATE_FILE}" ]; then
                LAST_PLAYING="$(python3 -c 'import json,sys; p=sys.argv[1]; 
try:
  o=json.load(open(p,"r",encoding="utf-8")); 
  print("true" if bool(o.get("playing",False)) else "false")
except Exception:
  print("false")' "${STATE_FILE}")"
                LAST_TS="$(python3 -c 'import json,sys; p=sys.argv[1];
try:
  o=json.load(open(p,"r",encoding="utf-8"));
  print((o.get("updated_utc") or "").strip())
except Exception:
  print("")' "${STATE_FILE}")"
              fi

              LAST_PLAYING="$(echo "${LAST_PLAYING}" | tr '[:upper:]' '[:lower:]')"
              if [ "${LAST_PLAYING}" != "true" ] && [ "${LAST_PLAYING}" != "false" ]; then
                LAST_PLAYING="false"
              fi

              # ----------------------------------------------------
              # Consulta Spotify (CURRENT_PLAYING true/false)
              # - Fuente primaria: /me/player
              # - Fallback si 204: /currently-playing
              # ----------------------------------------------------
              read -r CURRENT_PLAYING WHY NOWUTC <<EOF
$(python3 -c 'import os,base64,json,urllib.parse,urllib.request,urllib.error
from datetime import datetime,timezone

cid=os.environ.get("SPOTIFY_CLIENT_ID","").strip()
csec=os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
rt=os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
mode=(os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()

def refresh_token():
  auth=base64.b64encode(f"{cid}:{csec}".encode()).decode()
  data=urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
  req=urllib.request.Request("https://accounts.spotify.com/api/token", data=data,
    headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"}, method="POST")
  with urllib.request.urlopen(req, timeout=20) as r:
    payload=json.loads(r.read().decode("utf-8","replace"))
    return payload.get("access_token")

def get_json(url,tok):
  req=urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
  try:
    with urllib.request.urlopen(req, timeout=20) as r:
      raw=r.read().decode("utf-8","replace").strip()
      data=json.loads(raw) if raw else None
      return r.status,data
  except urllib.error.HTTPError as e:
    if e.code==204:
      return 204,None
    try:
      raw=e.read().decode("utf-8","replace").strip()
      data=json.loads(raw) if raw else raw
    except Exception:
      data=None
    return e.code,data
  except Exception:
    return -1,None

playing=False
reason="unknown"

if cid and csec and rt:
  tok=refresh_token()
  if tok:
    code,data=get_json("https://api.spotify.com/v1/me/player", tok)
    if code==200 and isinstance(data,dict):
      if mode=="ANY_SESSION":
        dev=data.get("device")
        playing=isinstance(dev,dict) and bool(dev)
        reason="player_any_session"
      else:
        playing=bool(data.get("is_playing"))
        reason="player_is_playing"
    elif code==204:
      c2,d2=get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
      if c2==200 and isinstance(d2,dict):
        playing=bool(d2.get("is_playing"))
        reason="currently_playing_fallback"
      else:
        playing=False
        reason="no_active_player"
    else:
      playing=False
      reason=f"player_http_{code}"
else:
  playing=False
  reason="missing_secrets"

now=datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")
print(("true" if playing else "false"), reason, now)' )
EOF

              CURRENT_PLAYING="$(echo "${CURRENT_PLAYING}" | tr '[:upper:]' '[:lower:]')"
              if [ "${CURRENT_PLAYING}" != "true" ] && [ "${CURRENT_PLAYING}" != "false" ]; then
                CURRENT_PLAYING="false"
              fi

              # ----------------------------------------------------
              # Cooldown anti-stuck
              # ----------------------------------------------------
              COOLDOWN_ALLOW="false"
              if [ -n "${LAST_TS}" ]; then
                COOLDOWN_ALLOW="$(python3 -c 'import os
from datetime import datetime,timezone
last=os.environ.get("LAST_TS","").strip()
cool=int(os.environ.get("COOLDOWN_MIN","20"))
try:
  dt=datetime.strptime(last,"%Y-%m-%d %H:%M:%SZ").replace(tzinfo=timezone.utc)
  now=datetime.now(timezone.utc)
  mins=(now-dt).total_seconds()/60.0
  print("true" if mins>=cool else "false")
except Exception:
  print("false")')"
                COOLDOWN_ALLOW="$(echo "${COOLDOWN_ALLOW}" | tr '[:upper:]' '[:lower:]')"
              fi

              # ----------------------------------------------------
              # Decisión:
              # - Cambio de estado => run
              # - Cooldown => run
              # - Si no => skip
              # ----------------------------------------------------
              if [ "${CURRENT_PLAYING}" != "${LAST_PLAYING}" ]; then
                SHOULD_RUN="true"
                REASON="state_changed_${LAST_PLAYING}_to_${CURRENT_PLAYING}_${WHY}"
              elif [ "${COOLDOWN_ALLOW}" = "true" ]; then
                SHOULD_RUN="true"
                REASON="cooldown_refresh_${WHY}"
              else
                SHOULD_RUN="false"
                REASON="no_change_${WHY}"
              fi

              # ----------------------------------------------------
              # Persistimos estado observado (determinista)
              # ----------------------------------------------------
              python3 -c 'import json,sys
p=sys.argv[1]; playing=(sys.argv[2].lower()=="true"); ts=sys.argv[3]
obj={"playing": playing, "updated_utc": ts}
open(p,"w",encoding="utf-8").write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")' \
                "${STATE_FILE}" "${CURRENT_PLAYING}" "${NOWUTC}"

              WROTE_STATE="true"
            fi
          fi

          echo "should_run=${SHOULD_RUN}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
          echo "wrote_state=${WROTE_STATE}" >> "$GITHUB_OUTPUT"
          echo "event=${EVENT}" >> "$GITHUB_OUTPUT"
          echo "schedule=${SCHEDULE}" >> "$GITHUB_OUTPUT"
          echo "Decision: should_run=${SHOULD_RUN} reason=${REASON} (event=${EVENT}, schedule=${SCHEDULE})"

      # ------------------------------------------------------------
      # Commit state file (solo si el fast poll lo escribió)
      # - NO spamea: solo commitea si git detecta diff real.
      # ------------------------------------------------------------
      - name: Commit fast-poll state (if changed)
        if: steps.guard.outputs.wrote_state == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No state changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .github/state/spotify_fastpoll_state.json
          git commit -m "chore: update fast-poll state"
          git push

      # ------------------------------------------------------------
      # Update telemetry (solo si guard dijo true)
      # ------------------------------------------------------------
      - name: Update Spotify telemetry block (fail-safe)
        if: steps.guard.outputs.should_run == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          python3 .github/scripts/spotify_telemetry.py

      # ------------------------------------------------------------
      # Commit & push README + last_report (solo si se ejecutó update)
      # ------------------------------------------------------------
      - name: Commit & push if changed
        if: steps.guard.outputs.should_run == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json
          git commit -m "chore: update Spotify telemetry (CLI feed)"
          git push
