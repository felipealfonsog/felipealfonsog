name: Voyager Telemetry (CLI style) - V1

on:
  workflow_dispatch:
  schedule:
    - cron: "23 */3 * * *"

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Update Voyager telemetry block
        run: |
          python3 - << 'PY'
          import json, math, re, urllib.parse, urllib.request
          import xml.etree.ElementTree as ET
          from datetime import datetime, timedelta, timezone

          DSN_XML_CANDIDATES = [
            "https://eyes.jpl.nasa.gov/dsn/data/dsn.xml",
            "https://eyes.nasa.gov/dsn/data/dsn.xml",
            "https://eyes.nasa.gov/apps/dsn-now/dsn.xml",
          ]

          HORIZONS_API = "https://ssd.jpl.nasa.gov/api/horizons.api"

          VOYAGERS = [
            ("VOYAGER 1", "-31"),
            ("VOYAGER 2", "-32"),
          ]

          C_KM_S = 299792.458
          AU_KM = 149597870.7

          def http_get(url: str, timeout: int = 25) -> bytes:
            req = urllib.request.Request(
              url,
              headers={
                "User-Agent": "github-actions-voyager-readme-bot",
                "Accept": "*/*",
                "Cache-Control": "no-cache",
                "Pragma": "no-cache",
              },
            )
            with urllib.request.urlopen(req, timeout=timeout) as r:
              return r.read()

          def fetch_dsn_xml():
            last_err = None
            for url in DSN_XML_CANDIDATES:
              try:
                data = http_get(url, timeout=20)
                if b"<dish" in data and b"<target" in data:
                  return url, data
              except Exception as e:
                last_err = e
                continue
            raise RuntimeError(f"DSN XML fetch failed: {last_err}")

          def parse_dsn(xml_bytes: bytes):
            root = ET.fromstring(xml_bytes)

            ts_utc = None
            ts = root.findtext(".//timestamp")
            if ts and ts.strip().isdigit():
              ts_utc = datetime.fromtimestamp(int(ts.strip())/1000, tz=timezone.utc)

            links = { "VOYAGER 1": [], "VOYAGER 2": [] }

            for dish in root.findall(".//dish"):
              dish_name = dish.get("name") or "?"
              for tgt in dish.findall(".//target"):
                tname = (tgt.get("name") or "").strip().upper()
                if tname not in links:
                  continue

                down = tgt.find(".//downSignal")
                up   = tgt.find(".//upSignal")

                def sig(node):
                  if node is None:
                    return {}
                  return {
                    "active": (node.get("active") or "false").lower(),
                    "dataRate": node.get("dataRate") or "",
                    "band": node.get("band") or "",
                    "signalType": node.get("signalType") or "",
                    "power": node.get("power") or "",
                    "frequency": node.get("frequency") or "",
                  }

                links[tname].append({
                  "dish": dish_name,
                  "down": sig(down),
                  "up": sig(up),
                })

            return ts_utc, links

          def best_dsn_link(entries):
            if not entries:
              return None
            for e in entries:
              if (e["down"].get("active") == "true") or (e["up"].get("active") == "true"):
                return e
            return entries[0]

          def horizons_vectors(spkid: str):
            now = datetime.now(timezone.utc).replace(second=0, microsecond=0)
            stop = now + timedelta(minutes=2)

            params = {
              "format": "json",
              "COMMAND": f"'{spkid}'",
              "MAKE_EPHEM": "YES",
              "TABLE_TYPE": "VECTORS",
              "CENTER": "'500@399'",
              "START_TIME": f"'{now.strftime('%Y-%m-%d %H:%M')}'",
              "STOP_TIME": f"'{stop.strftime('%Y-%m-%d %H:%M')}'",
              "STEP_SIZE": "'1 m'",
              "OUT_UNITS": "KM-S",
              "CSV_FORMAT": "YES",
              "VEC_TABLE": "3",
              "VEC_LABELS": "NO",
              "OBJ_DATA": "NO",
            }

            url = HORIZONS_API + "?" + urllib.parse.urlencode(params, safe="'@,:")
            data = json.loads(http_get(url).decode("utf-8", "replace"))
            txt = data.get("result", "")

            m = re.search(r"\$\$SOE\s*(.*?)\s*\$\$EOE", txt, flags=re.S)
            if not m:
              snippet = "\n".join(txt.splitlines()[:60])
              raise RuntimeError("Horizons: could not locate $$SOE/$$EOE block\n" + snippet)

            lines = [ln.strip() for ln in m.group(1).splitlines() if ln.strip()]
            row = None
            for ln in lines:
              parts = [p.strip() for p in ln.split(",")]
              if len(parts) >= 9:
                row = parts
                break
            if not row:
              raise RuntimeError("Horizons: no parseable CSV row found")

            floats = []
            for p in row:
              try:
                floats.append(float(p.replace("D","E")))
              except Exception:
                floats.append(None)

            start = None
            for i in range(len(floats) - 5):
              chunk = floats[i:i+6]
              if all(v is not None for v in chunk):
                start = i
                break
            if start is None:
              raise RuntimeError("Horizons: could not locate X,Y,Z,VX,VY,VZ numeric fields")

            x, y, z, vx, vy, vz = floats[start:start+6]

            dist_km = math.sqrt(x*x + y*y + z*z)
            speed_kms = math.sqrt(vx*vx + vy*vy + vz*vz)

            dist_au = dist_km / AU_KM
            one_way_s = dist_km / C_KM_S
            rt_s = one_way_s * 2

            return {
              "dist_km": dist_km,
              "dist_au": dist_au,
              "speed_kms": speed_kms,
              "one_way_s": one_way_s,
              "rt_s": rt_s,
            }

          def fmt_s_to_hms(sec: float) -> str:
            sec = int(round(sec))
            h = sec // 3600
            m = (sec % 3600) // 60
            s = sec % 60
            return f"{h:02d}:{m:02d}:{s:02d}"

          def fmt_km(n: float) -> str:
            if n >= 1e9: return f"{n/1e9:.2f}e9 km"
            if n >= 1e6: return f"{n/1e6:.2f}e6 km"
            return f"{n:.0f} km"

          now_utc = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")

          dsn_url, dsn_xml = fetch_dsn_xml()
          dsn_ts, dsn_links = parse_dsn(dsn_xml)
          dsn_ts_s = dsn_ts.strftime("%Y-%m-%d %H:%M:%SZ") if dsn_ts else "UNKNOWN"

          out = []
          out.append("VOYAGER TELEMETRY â€” CLI FEED (NASA/JPL)")
          out.append("------------------------------------------------------------")
          out.append(f"DSN endpoint (source)    : {dsn_url}")
          out.append(f"DSN snapshot (UTC)       : {dsn_ts_s}")

          for name, spkid in VOYAGERS:
            nav = None
            nav_err = None
            try:
              nav = horizons_vectors(spkid)
            except Exception as e:
              nav_err = str(e)

            link = best_dsn_link(dsn_links.get(name, []))
            lock_now = "TRUE" if (link and ((link["down"].get("active")=="true") or (link["up"].get("active")=="true"))) else "FALSE"

            if nav is None:
              sitrep = "RED"
            elif lock_now == "TRUE":
              sitrep = "GREEN"
            else:
              sitrep = "AMBER"

            out.append("------------------------------------------------------------")
            out.append(f"Target                   : {name}")
            out.append(f"SITREP                   : {sitrep}")
            out.append(f"DSN lock (now)           : {lock_now}")

            if lock_now == "FALSE":
              out.append("DSN note                 : No active DSN pass at snapshot time")

            if link:
              down = link["down"]
              up = link["up"]
              dish = link["dish"]
              dr = down.get("dataRate") or "-"
              band = down.get("band") or "-"
              pwr = down.get("power") or "-"
              frq = down.get("frequency") or "-"
              out.append(f"DSN dish                 : {dish}")
              out.append(f"Downlink                 : {dr} bps | band={band} | active={down.get('active','false')}")
              out.append(f"Uplink                   : active={up.get('active','false')} | type={up.get('signalType','-')}")
              out.append(f"Signal (power/freq)      : {pwr} dB | {frq}")
            else:
              out.append("DSN dish                 : -")
              out.append("Downlink                 : -")
              out.append("Uplink                   : -")
              out.append("Signal (power/freq)      : -")

            if nav:
              out.append("------------------------------------------------------------")
              out.append(f"Earth distance           : {fmt_km(nav['dist_km'])} | {nav['dist_au']:.3f} AU")
              out.append(f"Relative speed           : {nav['speed_kms']:.3f} km/s")
              out.append(f"One-way light time       : {fmt_s_to_hms(nav['one_way_s'])}")
              out.append(f"Round-trip latency       : {fmt_s_to_hms(nav['rt_s'])}")
            else:
              out.append("------------------------------------------------------------")
              out.append("NAV (Horizons)           : ERROR")
              out.append(f"Details                  : {nav_err}")

          out.append("------------------------------------------------------------")
          out.append("Interstellar data (ref)  : >65,000,000,000 bits returned (historical NASA milestone)")
          
          out.append("------------------------------------------------------------")
          out.append(f"Report generated (UTC)   : {now_utc}")


          block = "```text\n" + "\n".join(out).rstrip() + "\n```\n"

          readme_path = "README.md"
          with open(readme_path, "r", encoding="utf-8") as f:
            md = f.read()

          pattern = re.compile(r"<!-- VOYAGER:START -->.*?<!-- VOYAGER:END -->", re.S)
          if not pattern.search(md):
            raise SystemExit("Markers not found: <!-- VOYAGER:START --> ... <!-- VOYAGER:END -->")

          md2 = pattern.sub("<!-- VOYAGER:START -->\n\n" + block + "\n<!-- VOYAGER:END -->", md)

          with open(readme_path, "w", encoding="utf-8") as f:
            f.write(md2)
          PY

      - name: Commit changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md
          if git diff --cached --quiet; then
            echo "No changes."
            exit 0
          fi
          git commit -m "chore: update Voyager telemetry block"
          git push
