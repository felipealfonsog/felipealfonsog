name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:

  schedule:
    # ------------------------------------------------------------
    # NORMAL CRON (baseline / “como antes”)
    # - Siempre corre cada 3h, pase lo que pase
    # ------------------------------------------------------------
    - cron: "23 */3 * * *"

    # ------------------------------------------------------------
    # FAST POLL (cada 1 minuto)
    # - SOLO sirve para disparar una vez cuando detecta playback
    # - Con latch: NO repite mientras siga la misma sesión
    # ------------------------------------------------------------
    - cron: "* * * * *"

permissions:
  contents: write

concurrency:
  # ------------------------------------------------------------
  # Evita ejecuciones simultáneas pisándose entre sí
  # ------------------------------------------------------------
  group: spotify-telemetry-${{ github.ref }}
  cancel-in-progress: true

env:
  # ------------------------------------------------------------
  # Toggle maestro del fast poll
  # true  => habilita cron 1m + guard + latch
  # false => cron 1m se vuelve no-op, cron 3h sigue normal
  # ------------------------------------------------------------
  ENABLE_FAST_POLL: "true"        # true/false

  # ------------------------------------------------------------
  # Modo de decisión para el fast poll
  # PLAYING_ONLY => requiere is_playing=true
  # ANY_SESSION  => requiere sesión activa (device existe)
  # ------------------------------------------------------------
  FAST_POLL_MODE: "PLAYING_ONLY"  # PLAYING_ONLY | ANY_SESSION

  # ------------------------------------------------------------
  # Archivo latch (estado durable en el repo)
  # armed=true  => “listo para disparar”
  # armed=false => “ya disparó para esta sesión”
  # ------------------------------------------------------------
  LATCH_FILE: ".github/state/spotify_fastpoll_latch.json"

jobs:
  telemetry:
    runs-on: ubuntu-latest

    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Python runtime
      # ------------------------------------------------------------
      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # Guard + Latch
      #
      # - Para NORMAL (3h) y manual:
      #     Siempre corre (original).
      #
      # - Para FAST POLL (1m):
      #     Si ENABLE_FAST_POLL != true => skip.
      #     Si ENABLE_FAST_POLL == true:
      #       - Detecta playback
      #       - Latch:
      #           * NO playback => rearma armed=true y NO corre
      #           * playback:
      #               - armed=true  => corre y deja armed=false
      #               - armed=false => NO corre (ya disparó en esta sesión)
      # ------------------------------------------------------------
      - name: Guard (fast poll + latch)
        id: guard
        env:
          ENABLE_FAST_POLL: ${{ env.ENABLE_FAST_POLL }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
          LATCH_FILE: ${{ env.LATCH_FILE }}
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          SCHEDULE="${{ github.event.schedule }}"

          SHOULD_RUN="true"
          REASON="normal_or_manual"
          CHANGED_LATCH="false"

          FAST_CRON="* * * * *"

          if [ "${EVENT}" = "schedule" ] && [ "${SCHEDULE}" = "${FAST_CRON}" ]; then
            EN="$(echo "${ENABLE_FAST_POLL}" | tr '[:upper:]' '[:lower:]')"

            if [ "${EN}" != "true" ]; then
              SHOULD_RUN="false"
              REASON="fast_poll_disabled"
            else
              mkdir -p "$(dirname "${LATCH_FILE}")"

              # -----------------------------
              # Read latch (default armed=true)
              # -----------------------------
              ARMED="true"
              if [ -f "${LATCH_FILE}" ]; then
                cat > /tmp/read_latch.py <<'PY'
import json, sys
p = sys.argv[1]
try:
  obj = json.load(open(p, "r", encoding="utf-8"))
  armed = obj.get("armed", True)
  print("true" if armed else "false")
except Exception:
  print("true")
PY
                ARMED="$(python3 /tmp/read_latch.py "${LATCH_FILE}" | tr '[:upper:]' '[:lower:]')"
              fi

              if [ "${ARMED}" != "true" ] && [ "${ARMED}" != "false" ]; then
                ARMED="true"
              fi

              # -----------------------------
              # Spotify precheck -> "true reason" | "false reason"
              # -----------------------------
              cat > /tmp/spotify_check.py <<'PY'
              import os, base64, json, urllib.parse, urllib.request, urllib.error
              
              cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
              csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
              rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
              mode = (os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()
              
              def refresh_token():
                auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
                data = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
                req = urllib.request.Request(
                  "https://accounts.spotify.com/api/token",
                  data=data,
                  headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"},
                  method="POST",
                )
                with urllib.request.urlopen(req, timeout=20) as r:
                  payload = json.loads(r.read().decode("utf-8","replace"))
                  return payload.get("access_token")
              
              def get_json(url, tok):
                req = urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
                try:
                  with urllib.request.urlopen(req, timeout=20) as r:
                    raw = r.read().decode("utf-8","replace").strip()
                    data = json.loads(raw) if raw else None
                    return r.status, data
                except urllib.error.HTTPError as e:
                  if e.code == 204:
                    return 204, None
                  try:
                    raw = e.read().decode("utf-8","replace").strip()
                    data = json.loads(raw) if raw else raw
                  except Exception:
                    data = None
                  return e.code, data
                except Exception:
                  return -1, None
              
              playing = False
              reason = "unknown"
              
              if cid and csec and rt:
                tok = refresh_token()
                if tok:
                  code, data = get_json("https://api.spotify.com/v1/me/player", tok)
                  if code == 200 and isinstance(data, dict):
                    if mode == "ANY_SESSION":
                      dev = data.get("device")
                      playing = isinstance(dev, dict) and bool(dev)
                      reason = "player_any_session"
                    else:
                      playing = bool(data.get("is_playing"))
                      reason = "player_is_playing"
                  elif code == 204:
                    c2, d2 = get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
                    if c2 == 200 and isinstance(d2, dict):
                      playing = bool(d2.get("is_playing"))
                      reason = "currently_playing_fallback"
                    else:
                      playing = False
                      reason = "no_active_player"
                  else:
                    playing = False
                    reason = f"player_http_{code}"
                else:
                  playing = False
                  reason = "token_failed"
              else:
                playing = False
                reason = "missing_secrets"
              
              print(("true" if playing else "false") + " " + reason)
              PY

              read -r PLAYING WHY < <(python3 /tmp/spotify_check.py)
              PLAYING="$(echo "${PLAYING}" | tr '[:upper:]' '[:lower:]')"

              # -----------------------------
              # Latch algorithm
              # -----------------------------
              if [ "${PLAYING}" != "true" ]; then
                SHOULD_RUN="false"
                REASON="not_playing_${WHY}"

                if [ "${ARMED}" != "true" ]; then
                  cat > /tmp/write_latch_arm.py <<'PY'
              import json, sys
              from datetime import datetime, timezone
              p = sys.argv[1]
              obj = {"armed": True, "updated_utc": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")}
              open(p, "w", encoding="utf-8").write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")
              PY
                  python3 /tmp/write_latch_arm.py "${LATCH_FILE}"
                  CHANGED_LATCH="true"
                fi
              else
                if [ "${ARMED}" = "true" ]; then
                  SHOULD_RUN="true"
                  REASON="triggered_${WHY}"

                  cat > /tmp/write_latch_disarm.py <<'PY'
                import json, sys
                from datetime import datetime, timezone
                p = sys.argv[1]
                obj = {"armed": False, "updated_utc": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%SZ")}
                open(p, "w", encoding="utf-8").write(json.dumps(obj, ensure_ascii=False, indent=2) + "\n")
                PY
                  python3 /tmp/write_latch_disarm.py "${LATCH_FILE}"
                  CHANGED_LATCH="true"
                else
                  SHOULD_RUN="false"
                  REASON="already_triggered_${WHY}"
                fi
              fi
            fi
          fi

          echo "should_run=${SHOULD_RUN}" >> "$GITHUB_OUTPUT"
          echo "reason=${REASON}" >> "$GITHUB_OUTPUT"
          echo "changed_latch=${CHANGED_LATCH}" >> "$GITHUB_OUTPUT"
          echo "event=${EVENT}" >> "$GITHUB_OUTPUT"
          echo "schedule=${SCHEDULE}" >> "$GITHUB_OUTPUT"

          echo "Decision: should_run=${SHOULD_RUN} reason=${REASON} changed_latch=${CHANGED_LATCH} (event=${EVENT}, schedule=${SCHEDULE})"

      # ------------------------------------------------------------
      # Commit latch state (si cambió)
      # ------------------------------------------------------------
          - name: Commit latch state (if changed)
            if: steps.guard.outputs.changed_latch == 'true'
            run: |
              set -euo pipefail
              if git diff --quiet; then
                echo "No latch changes."
                exit 0
              fi
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add .github/state/spotify_fastpoll_latch.json
              git commit -m "chore: fast-poll latch update"
              git push
    
          # ------------------------------------------------------------
          # Update telemetry (solo si guard dijo "true")
          # ------------------------------------------------------------
          - name: Update Spotify telemetry block (fail-safe)
            if: steps.guard.outputs.should_run == 'true'
            env:
              SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
              SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
              SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
            run: |
              set -euo pipefail
              python3 .github/scripts/spotify_telemetry.py
    
          # ------------------------------------------------------------
          # Commit & push telemetry (solo si guard dijo "true")
          # ------------------------------------------------------------
          - name: Commit & push if changed
            if: steps.guard.outputs.should_run == 'true'
            run: |
              set -euo pipefail
              if git diff --quiet; then
                echo "No changes."
                exit 0
              fi
              git config user.name "github-actions[bot]"
              git config user.email "github-actions[bot]@users.noreply.github.com"
              git add README.md .github/state/spotify_last_report.json
              git commit -m "chore: update Spotify telemetry (CLI feed)"
              git push
