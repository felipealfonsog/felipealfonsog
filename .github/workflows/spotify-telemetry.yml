name: Spotify Telemetry (CLI feed)

on:
  workflow_dispatch:
  schedule:
    # ------------------------------------------------------------
    # NORMAL CRON (baseline)
    # - Siempre corre cada 3h, pase lo que pase
    # ------------------------------------------------------------
    - cron: "23 */3 * * *"

    # ------------------------------------------------------------
    # OBSERVER (cada 2 minutos)
    # - Observa estado (PLAYING/IDLE)
    # - Rearma latch al quedar IDLE
    # - Consume latch UNA sola vez al entrar en PLAYING
    # - Si latch se consume => gatilla update del README 1 vez
    # ------------------------------------------------------------
    - cron: "*/2 * * * *"

permissions:
  contents: write
  issues: write

# ------------------------------------------------------------
# IMPORTANTE:
# - No cancelamos runs en progreso.
# - El anti-spam lo hace el latch + NO tener cron 1-min.
# ------------------------------------------------------------
concurrency:
  group: spotify-telemetry
  cancel-in-progress: false

env:
  # ------------------------------------------------------------
  # ENABLES
  # ------------------------------------------------------------
  ENABLE_OBSERVER: "true"         # true/false
  ENABLE_STORM_REPORT: "true"     # true/false
  ENABLE_STORM_ISSUE: "true"      # true/false

  # ------------------------------------------------------------
  # Spotify mode
  # ------------------------------------------------------------
  FAST_POLL_MODE: "PLAYING_ONLY"  # PLAYING_ONLY | ANY_SESSION

  # ------------------------------------------------------------
  # State / latch files (persistidos en repo)
  # ------------------------------------------------------------
  STATE_FILE: ".github/state/spotify_playback_state.json"
  LATCH_FILE: ".github/state/spotify_fastpoll_latch.json"
  LATCH_COOLDOWN_MINUTES: "20"

  # ------------------------------------------------------------
  # Strings exactos para identificar schedules
  # ------------------------------------------------------------
  CRON_BASELINE: "23 */3 * * *"
  CRON_OBSERVER: "*/2 * * * *"

  # ------------------------------------------------------------
  # STORM DETECTOR (muchos workflow-runs seguidos)
  # ------------------------------------------------------------
  STORM_WINDOW_MINUTES: "15"
  STORM_THRESHOLD: "10"
  WORKFLOW_FILE: "spotify-telemetry.yml"

jobs:
  telemetry:
    runs-on: ubuntu-latest

    steps:
      # ------------------------------------------------------------
      # Checkout
      # ------------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Python runtime
      # ------------------------------------------------------------
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ------------------------------------------------------------
      # Ensure state dir exists
      # ------------------------------------------------------------
      - name: Ensure state directory
        run: |
          set -euo pipefail
          mkdir -p .github/state

      # ------------------------------------------------------------
      # Debug context
      # ------------------------------------------------------------
      - name: Debug context (event/schedule)
        run: |
          set -euo pipefail
          echo "event_name=${{ github.event_name }}"
          echo "schedule=${{ github.event.schedule || '' }}"
          echo "ref=${{ github.ref }}"
          echo "sha=${{ github.sha }}"

      # ------------------------------------------------------------
      # Resolve run-mode (baseline | observer | manual)
      # ------------------------------------------------------------
      - name: Resolve run mode
        id: mode
        env:
          CRON_BASELINE: ${{ env.CRON_BASELINE }}
          CRON_OBSERVER: ${{ env.CRON_OBSERVER }}
        run: |
          set -euo pipefail

          EVENT="${{ github.event_name }}"
          SCHEDULE="${{ github.event.schedule || '' }}"

          MODE="manual"
          if [ "${EVENT}" = "schedule" ]; then
            if [ "${SCHEDULE}" = "${CRON_BASELINE}" ]; then
              MODE="baseline"
            elif [ "${SCHEDULE}" = "${CRON_OBSERVER}" ]; then
              MODE="observer"
            else
              MODE="unknown_schedule"
            fi
          fi

          echo "mode=${MODE}" >> "$GITHUB_OUTPUT"
          echo "event=${EVENT}" >> "$GITHUB_OUTPUT"
          echo "schedule=${SCHEDULE}" >> "$GITHUB_OUTPUT"
          echo "Resolved MODE=${MODE} (event=${EVENT}, schedule=${SCHEDULE})"

      # ------------------------------------------------------------
      # Spotify precheck (solo observer)
      # - Produce: playing=true/false, why=...
      # ------------------------------------------------------------
      - name: Spotify precheck (compute playing flag)
        id: sp
        if: env.ENABLE_OBSERVER == 'true' && steps.mode.outputs.mode == 'observer'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
          FAST_POLL_MODE: ${{ env.FAST_POLL_MODE }}
        run: |
          set -euo pipefail

          python3 - <<'PY' > /tmp/spotify_check.txt
          import os, base64, json, urllib.parse, urllib.request, urllib.error

          cid = os.environ.get("SPOTIFY_CLIENT_ID","").strip()
          csec = os.environ.get("SPOTIFY_CLIENT_SECRET","").strip()
          rt = os.environ.get("SPOTIFY_REFRESH_TOKEN","").strip()
          mode = (os.environ.get("FAST_POLL_MODE","PLAYING_ONLY") or "PLAYING_ONLY").upper()

          def refresh_token():
            auth = base64.b64encode(f"{cid}:{csec}".encode()).decode()
            data = urllib.parse.urlencode({"grant_type":"refresh_token","refresh_token":rt}).encode("utf-8")
            req = urllib.request.Request(
              "https://accounts.spotify.com/api/token",
              data=data,
              headers={"Authorization": f"Basic {auth}", "Content-Type":"application/x-www-form-urlencoded"},
              method="POST",
            )
            with urllib.request.urlopen(req, timeout=20) as r:
              payload = json.loads(r.read().decode("utf-8","replace"))
              return payload.get("access_token")

          def get_json(url, tok):
            req = urllib.request.Request(url, headers={"Authorization": f"Bearer {tok}"})
            try:
              with urllib.request.urlopen(req, timeout=20) as r:
                raw = r.read().decode("utf-8","replace").strip()
                data = json.loads(raw) if raw else None
                return r.status, data
            except urllib.error.HTTPError as e:
              if e.code == 204:
                return 204, None
              try:
                raw = e.read().decode("utf-8","replace").strip()
                data = json.loads(raw) if raw else raw
              except Exception:
                data = None
              return e.code, data
            except Exception:
              return -1, None

          playing = False
          why = "unknown"

          if cid and csec and rt:
            tok = refresh_token()
            if tok:
              if mode == "PLAYING_ONLY":
                c1, d1 = get_json("https://api.spotify.com/v1/me/player/currently-playing", tok)
                if c1 == 200 and isinstance(d1, dict):
                  playing = bool(d1.get("is_playing"))
                  why = "currently_playing_primary"
                elif c1 == 204:
                  playing = False
                  why = "currently_playing_204"
                else:
                  playing = False
                  why = f"currently_playing_http_{c1}"
              else:
                c2, d2 = get_json("https://api.spotify.com/v1/me/player", tok)
                if c2 == 200 and isinstance(d2, dict):
                  dev = d2.get("device")
                  playing = isinstance(dev, dict) and bool(dev)
                  why = "player_any_session"
                elif c2 == 204:
                  playing = False
                  why = "player_204"
                else:
                  playing = False
                  why = f"player_http_{c2}"
            else:
              playing = False
              why = "token_refresh_failed"
          else:
            playing = False
            why = "missing_secrets"

          print(("true" if playing else "false") + " " + why)
          PY

          PLAYING="$(awk '{print $1}' /tmp/spotify_check.txt | tail -n1 | tr '[:upper:]' '[:lower:]')"
          WHY="$(awk '{print $2}' /tmp/spotify_check.txt | tail -n1)"
          rm -f /tmp/spotify_check.txt

          echo "playing=${PLAYING}" >> "$GITHUB_OUTPUT"
          echo "why=${WHY}" >> "$GITHUB_OUTPUT"
          echo "Spotify playing=${PLAYING} why=${WHY}"

      # ------------------------------------------------------------
      # OBSERVER: state + latch
      # - SOLO escribe/commitea si hay cambio real (no timestamps sueltos)
      # - latch:
      #   * IDLE => armado=true
      #   * PLAYING y armado=true => consume (armado=false) y habilita update 1 vez
      # ------------------------------------------------------------
      - name: Observer (state + latch + change detect)
        id: obs
        if: env.ENABLE_OBSERVER == 'true' && steps.mode.outputs.mode == 'observer'
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          LATCH_FILE: ${{ env.LATCH_FILE }}
          LATCH_COOLDOWN_MINUTES: ${{ env.LATCH_COOLDOWN_MINUTES }}
          PLAYING: ${{ steps.sp.outputs.playing }}
          WHY: ${{ steps.sp.outputs.why }}
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${STATE_FILE}")"
          mkdir -p "$(dirname "${LATCH_FILE}")"

          python3 - <<'PY' > /tmp/observer_out.txt
          import json, os
          from datetime import datetime, timezone

          state_path = os.environ["STATE_FILE"]
          latch_path = os.environ["LATCH_FILE"]
          cooldown_min = int((os.environ.get("LATCH_COOLDOWN_MINUTES","20") or "20").strip())
          playing = (os.environ.get("PLAYING","false").lower() == "true")
          why = os.environ.get("WHY","unknown")

          now = datetime.now(timezone.utc)
          now_s = now.strftime("%Y-%m-%d %H:%M:%SZ")
          new_state = "PLAYING" if playing else "IDLE"

          # ---- read previous state (for change detection)
          prev_state = None
          try:
            with open(state_path, "r", encoding="utf-8") as f:
              old = json.load(f)
              if isinstance(old, dict):
                prev_state = old.get("state")
          except Exception:
            pass

          state_changed = (prev_state is None) or (prev_state != new_state)

          # ---- read latch
          latch = {"armed": True, "last_trigger_utc": None}
          try:
            with open(latch_path, "r", encoding="utf-8") as f:
              cur = json.load(f)
              if isinstance(cur, dict):
                latch.update(cur)
          except Exception:
            pass

          def parse_ts(s):
            if not s:
              return None
            try:
              return datetime.fromisoformat(s.replace("Z","+00:00"))
            except Exception:
              return None

          # Anti-stuck: rearma si quedÃ³ desarmado demasiado rato
          if not bool(latch.get("armed", True)):
            lt = parse_ts(latch.get("last_trigger_utc"))
            if lt is not None:
              age_sec = (now - lt).total_seconds()
              if age_sec >= cooldown_min * 60:
                latch["armed"] = True
                latch["cooldown_rearm_utc"] = now_s
            else:
              latch["armed"] = True
              latch["cooldown_rearm_utc"] = now_s

          # Regla principal: IDLE rearma
          if not playing:
            latch["armed"] = True
            latch["rearm_utc"] = now_s

          # Consumir latch SOLO una vez al entrar en PLAYING
          latch_triggered = False
          if playing and bool(latch.get("armed", True)):
            latch["armed"] = False
            latch["last_trigger_utc"] = now_s
            latch_triggered = True

          # ---- write files ONLY if they would differ
          state_obj = {"state": new_state, "why": why, "updated_utc": now_s}
          with open(state_path, "w", encoding="utf-8") as f:
            f.write(json.dumps(state_obj, ensure_ascii=False, indent=2) + "\n")

          latch["updated_utc"] = now_s
          with open(latch_path, "w", encoding="utf-8") as f:
            f.write(json.dumps(latch, ensure_ascii=False, indent=2) + "\n")

          print(f"state_changed={'true' if state_changed else 'false'}")
          print(f"latch_triggered={'true' if latch_triggered else 'false'}")
          print(f"new_state={new_state}")
          print(f"prev_state={prev_state}")
          PY

          STATE_CHANGED="$(grep -E '^state_changed=' /tmp/observer_out.txt | cut -d= -f2 | tail -n1)"
          LATCH_TRIG="$(grep -E '^latch_triggered=' /tmp/observer_out.txt | cut -d= -f2 | tail -n1)"
          rm -f /tmp/observer_out.txt

          echo "state_changed=${STATE_CHANGED}" >> "$GITHUB_OUTPUT"
          echo "latch_triggered=${LATCH_TRIG}" >> "$GITHUB_OUTPUT"
          echo "Observer: state_changed=${STATE_CHANGED} latch_triggered=${LATCH_TRIG}"

      - name: Commit observer state/latch (only if changed)
        if: env.ENABLE_OBSERVER == 'true' && steps.mode.outputs.mode == 'observer'
        env:
          STATE_FILE: ${{ env.STATE_FILE }}
          LATCH_FILE: ${{ env.LATCH_FILE }}
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "Observer: no state/latch changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add "${STATE_FILE}" "${LATCH_FILE}"
          git commit -m "chore: update spotify observer state"
          git push

      # ------------------------------------------------------------
      # Decide update:
      # - baseline/manual => siempre
      # - observer => SOLO si latch_triggered=true (o sea, solo 1 vez por sesiÃ³n)
      # ------------------------------------------------------------
      - name: Decide whether to update README
        id: decide
        run: |
          set -euo pipefail

          MODE="${{ steps.mode.outputs.mode }}"
          LATCH_TRIG="${{ steps.obs.outputs.latch_triggered || 'false' }}"

          DO="false"
          WHY="none"

          if [ "${MODE}" = "baseline" ] || [ "${MODE}" = "manual" ]; then
            DO="true"
            WHY="baseline_or_manual"
          elif [ "${MODE}" = "observer" ] && [ "${LATCH_TRIG}" = "true" ]; then
            DO="true"
            WHY="observer_latch_trigger"
          fi

          echo "do_update=${DO}" >> "$GITHUB_OUTPUT"
          echo "why=${WHY}" >> "$GITHUB_OUTPUT"
          echo "Decision: do_update=${DO} why=${WHY} (mode=${MODE}, latch_triggered=${LATCH_TRIG})"

      # ------------------------------------------------------------
      # Update README
      # ------------------------------------------------------------
      - name: Update Spotify telemetry block (fail-safe)
        if: steps.decide.outputs.do_update == 'true'
        env:
          SPOTIFY_CLIENT_ID: ${{ secrets.SPOTIFY_CLIENT_ID }}
          SPOTIFY_CLIENT_SECRET: ${{ secrets.SPOTIFY_CLIENT_SECRET }}
          SPOTIFY_REFRESH_TOKEN: ${{ secrets.SPOTIFY_REFRESH_TOKEN }}
        run: |
          set -euo pipefail
          python3 .github/scripts/spotify_telemetry.py

      - name: Commit & push telemetry if changed
        if: steps.decide.outputs.do_update == 'true'
        run: |
          set -euo pipefail
          if git diff --quiet; then
            echo "No telemetry changes."
            exit 0
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add README.md .github/state/spotify_last_report.json
          git commit -m "chore: update Spotify telemetry (CLI feed)"
          git push

      # ------------------------------------------------------------
      # Upload debug artifact (si existe)
      # ------------------------------------------------------------
      - name: Upload Spotify debug
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: spotify-debug
          path: .github/state/spotify_debug.json
          if-no-files-found: ignore

      # ============================================================
      # STORM DETECTOR
      # - cuenta runs recientes de ESTE workflow
      # - report_md -> summary
      # - issue alert (toggle) con dedupe por ventana
      # ============================================================
      - name: Storm detector (count recent workflow runs)
        id: storm
        if: always()
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_FULL: ${{ github.repository }}
          WORKFLOW_FILE: ${{ env.WORKFLOW_FILE }}
          WINDOW_MIN: ${{ env.STORM_WINDOW_MINUTES }}
          THRESHOLD: ${{ env.STORM_THRESHOLD }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os, json
          from datetime import datetime, timezone, timedelta
          import urllib.request

          token = os.environ["GH_TOKEN"]
          repo_full = os.environ["REPO_FULL"]
          owner, repo = repo_full.split("/", 1)

          wf = os.environ["WORKFLOW_FILE"]
          window_min = int(os.environ.get("WINDOW_MIN","15"))
          threshold = int(os.environ.get("THRESHOLD","10"))

          since = datetime.now(timezone.utc) - timedelta(minutes=window_min)

          url = f"https://api.github.com/repos/{owner}/{repo}/actions/workflows/{wf}/runs?per_page=100"
          req = urllib.request.Request(
            url,
            headers={
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "storm-detector",
            },
          )

          with urllib.request.urlopen(req, timeout=20) as r:
            data = json.loads(r.read().decode("utf-8","replace"))

          runs = data.get("workflow_runs", []) if isinstance(data, dict) else []

          def parse_ts(s: str):
            return datetime.fromisoformat(s.replace("Z","+00:00"))

          recent = []
          for run in runs:
            try:
              created = parse_ts(run.get("created_at",""))
              if created >= since:
                recent.append(run)
            except Exception:
              continue

          count = len(recent)
          alert = count >= threshold

          lines = []
          lines.append("## ðŸš¨ Workflow Storm Detector")
          lines.append("")
          lines.append(f"- **Repo:** `{owner}/{repo}`")
          lines.append(f"- **Workflow:** `{wf}`")
          lines.append(f"- **Window:** last **{window_min}** minutes")
          lines.append(f"- **Threshold:** **{threshold}**")
          lines.append(f"- **Count:** **{count}**")
          lines.append(f"- **Alert:** **{'YES' if alert else 'NO'}**")
          lines.append("")
          lines.append("### Recent runs (newest first)")
          lines.append("")
          show = recent[:20]
          if not show:
            lines.append("_No runs found in the window._")
          else:
            for run in show:
              lines.append(f"- #{run.get('run_number')} | {run.get('status')} | {run.get('conclusion')} | {run.get('html_url')}")

          report_md = "\n".join(lines)

          out = os.environ["GITHUB_OUTPUT"]
          with open(out, "a", encoding="utf-8") as f:
            f.write(f"alert={'true' if alert else 'false'}\n")
            f.write(f"count={count}\n")
            f.write("report_md<<__REPORT__\n")
            f.write(report_md + "\n")
            f.write("__REPORT__\n")
          PY

      - name: Emergency report (Job Summary)
        if: steps.storm.outputs.alert == 'true' && (env.ENABLE_STORM_REPORT == 'true' || env.ENABLE_STORM_REPORT == 'TRUE')
        run: |
          set -euo pipefail
          {
            echo "${{ steps.storm.outputs.report_md }}"
            echo ""
            echo "> Triggered by storm condition: count=${{ steps.storm.outputs.count }} in window=${{ env.STORM_WINDOW_MINUTES }}m threshold=${{ env.STORM_THRESHOLD }}"
          } >> "$GITHUB_STEP_SUMMARY"

      # ------------------------------------------------------------
      # Internal GitHub alert via Issue (toggle + dedupe)
      # - Crea issue SOLO si no existe ya uno para la misma ventana
      # ------------------------------------------------------------
      - name: Emergency alert (GitHub Issue) [toggle + dedupe]
        if: steps.storm.outputs.alert == 'true' && (env.ENABLE_STORM_ISSUE == 'true' || env.ENABLE_STORM_ISSUE == 'TRUE')
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_FULL: ${{ github.repository }}
          WINDOW_MIN: ${{ env.STORM_WINDOW_MINUTES }}
          THRESHOLD: ${{ env.STORM_THRESHOLD }}
          COUNT: ${{ steps.storm.outputs.count }}
          REPORT_MD: ${{ steps.storm.outputs.report_md }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os, json, urllib.request, urllib.parse
          from datetime import datetime, timezone

          token = os.environ["GH_TOKEN"]
          repo_full = os.environ["REPO_FULL"]
          owner, repo = repo_full.split("/", 1)

          window_min = os.environ.get("WINDOW_MIN","15")
          threshold = os.environ.get("THRESHOLD","10")
          count = os.environ.get("COUNT","0")

          now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%MZ")
          title = f"ðŸš¨ Actions storm detected ({count}+ runs / {window_min}m) [{now}]"

          # Dedup key: same window/threshold/count bucket in title search
          dedupe_q = f'repo:{owner}/{repo} is:issue is:open "Actions storm detected" "{window_min}m" "{threshold}"'
          search_url = "https://api.github.com/search/issues?" + urllib.parse.urlencode({"q": dedupe_q})

          def req(url, method="GET", data=None):
            headers = {
              "Authorization": f"Bearer {token}",
              "Accept": "application/vnd.github+json",
              "X-GitHub-Api-Version": "2022-11-28",
              "User-Agent": "storm-issue",
            }
            if data is not None:
              headers["Content-Type"] = "application/json"
              data = json.dumps(data).encode("utf-8")
            r = urllib.request.Request(url, headers=headers, method=method, data=data)
            with urllib.request.urlopen(r, timeout=20) as resp:
              return resp.status, json.loads(resp.read().decode("utf-8","replace"))

          # If there's already an open issue, skip creating a new one
          _, search = req(search_url, "GET")
          items = search.get("items", []) if isinstance(search, dict) else []
          if items:
            print("Issue dedupe: existing open issue found -> skip create")
            return

          body = []
          body.append("### ðŸš¨ GitHub Actions Storm Detector")
          body.append("")
          body.append(f"- Repo: `{owner}/{repo}`")
          body.append(f"- Window: **{window_min} minutes**")
          body.append(f"- Threshold: **{threshold}**")
          body.append(f"- Count: **{count}**")
          body.append("")
          body.append("### Report")
          body.append("")
          body.append(os.environ.get("REPORT_MD","(no report)"))

          create_url = f"https://api.github.com/repos/{owner}/{repo}/issues"
          payload = {
            "title": title,
            "body": "\n".join(body),
            "labels": ["automation", "alert", "storm"],
          }
          status, created = req(create_url, "POST", payload)
          print(f"Issue created: status={status} url={created.get('html_url')}")
          PY

      # ------------------------------------------------------------
      # (Opcional) Log final en consola, Ãºtil para auditorÃ­a rÃ¡pida
      # ------------------------------------------------------------
      - name: Storm detector result (log)
        if: always()
        run: |
          set -euo pipefail
          echo "storm_alert=${{ steps.storm.outputs.alert }}"
          echo "storm_count=${{ steps.storm.outputs.count }}"
          echo "storm_window_minutes=${{ env.STORM_WINDOW_MINUTES }}"
          echo "storm_threshold=${{ env.STORM_THRESHOLD }}"
